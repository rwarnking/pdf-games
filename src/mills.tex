\documentclass[12pt, a4paper, footexclude, headexclude]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[margin=0.5in]{geometry}

\usepackage[pdftex]{hyperref}
\usepackage{multicol}

\usepackage{xinttools}
\usepackage{tabularx}
\usepackage{tcolorbox}

\usepackage{tikz}

\setlength{\parindent}{0pt}

\usepackage[pdftex]{insdljs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\rows{3}
\def\columns{8}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Javascript
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{insDLJS}[]{JSDateiname}{mills}

const GAME_DESC = "This game has three phases:\
1. Each player places 9 stones onto the field.\
2. Each turn a player is allowed to move a stone to an adjacent cell.\
3. If in step 1 or 2 a mill is constructed, the player removes a stone of the opponent.\
Three stones on a straight line are a mill. A player with only 3 stones left,\
can moves his stones on any empty cell. The game is over as soon as one player\
has only 2 stones left or cant make a valid move.";

% Outside variables
const ROWS = AFMakeNumber(\rows);
const COLUMNS = AFMakeNumber(\columns);
% Obacht: The player count is not really changeable,
% since not all functions support != 2 player
const PLAYER_COUNT = 2;
const TEXT_SIZE = 25;

% Constants
const EMPTY = -1;
const P_1 = 0;
const P_2 = 1;
const PIECE_SYMBOL = String.fromCharCode(0x25CF);
const P_COUNT = 9;

const PLACING = 0;
const MOVING = 1;
const REMOVING = 2;

const ANIMATION_SPEED = 33;
const ANIMATION_OFFSET = 0.05;

% Globals
% Animation interval variable for moving
var run;
var timestep = 0.0;
% The game field
var complField = [
    [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY],
    [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY],
    [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY]
];
% Game logic vars
var gamestate = PLACING;
var gameover = false;
var turn = P_1;
var lastClick = null;
var stonesToPlace = [P_COUNT, P_COUNT];
var stones = [0, 0];

%%%%%%%%%%%%%%%
% Positioning %
%%%%%%%%%%%%%%%
const MAX_WIDTH = 596;
const MAX_HEIGHT = 842;

const MARGIN_X = 50;
const MARGIN_Y_TOP = 100;
const BOX_S = 30;
const MAX_X_POS = MAX_WIDTH - MARGIN_X;
const MIN_X_POS = MARGIN_X;
const MAX_Y_POS = MAX_HEIGHT - MARGIN_Y_TOP;
const MIN_Y_POS = MAX_Y_POS - MAX_X_POS + MARGIN_X;

const X_POS_H = MIN_X_POS + (MAX_X_POS - MIN_X_POS) * 0.5;
const Y_POS_H = MIN_Y_POS + (MAX_Y_POS - MIN_Y_POS) * 0.5;
const X_POS_56 = MIN_X_POS + (MAX_X_POS - MIN_X_POS) * 5/6;
const Y_POS_56 = MIN_Y_POS + (MAX_Y_POS - MIN_Y_POS) * 5/6;
const X_POS_16 = MIN_X_POS + (MAX_X_POS - MIN_X_POS) * 1/6;
const Y_POS_16 = MIN_Y_POS + (MAX_Y_POS - MIN_Y_POS) * 1/6;
const X_POS_46 = MIN_X_POS + (MAX_X_POS - MIN_X_POS) * 4/6;
const Y_POS_46 = MIN_Y_POS + (MAX_Y_POS - MIN_Y_POS) * 4/6;
const X_POS_26 = MIN_X_POS + (MAX_X_POS - MIN_X_POS) * 2/6;
const Y_POS_26 = MIN_Y_POS + (MAX_Y_POS - MIN_Y_POS) * 2/6;
const BOX_S_H = BOX_S * 0.5;

% upper-left x, upper-left y, lower-right x and lower-right y
const BOX_POSITIONS = [
    % Outer row
    [[MIN_X_POS - BOX_S_H, MAX_Y_POS + BOX_S_H, MIN_X_POS + BOX_S_H, MAX_Y_POS - BOX_S_H],
    [X_POS_H - BOX_S_H, MAX_Y_POS + BOX_S_H, X_POS_H + BOX_S_H, MAX_Y_POS - BOX_S_H],
    [MAX_X_POS - BOX_S_H, MAX_Y_POS + BOX_S_H, MAX_X_POS + BOX_S_H, MAX_Y_POS - BOX_S_H],
    [MAX_X_POS - BOX_S_H, Y_POS_H + BOX_S_H, MAX_X_POS + BOX_S_H, Y_POS_H - BOX_S_H],
    [MAX_X_POS - BOX_S_H, MIN_Y_POS + BOX_S_H, MAX_X_POS + BOX_S_H, MIN_Y_POS - BOX_S_H],
    [X_POS_H - BOX_S_H, MIN_Y_POS + BOX_S_H, X_POS_H + BOX_S_H, MIN_Y_POS - BOX_S_H],
    [MIN_X_POS - BOX_S_H, MIN_Y_POS + BOX_S_H, MIN_X_POS + BOX_S_H, MIN_Y_POS - BOX_S_H],
    [MIN_X_POS - BOX_S_H, Y_POS_H + BOX_S_H, MIN_X_POS + BOX_S_H, Y_POS_H - BOX_S_H]],
    % Middle row
    [[X_POS_16 - BOX_S_H, Y_POS_56 + BOX_S_H, X_POS_16 + BOX_S_H, Y_POS_56 - BOX_S_H],
    [X_POS_H - BOX_S_H, Y_POS_56 + BOX_S_H, X_POS_H + BOX_S_H, Y_POS_56 - BOX_S_H],
    [X_POS_56 - BOX_S_H, Y_POS_56 + BOX_S_H, X_POS_56 + BOX_S_H, Y_POS_56 - BOX_S_H],
    [X_POS_56 - BOX_S_H, Y_POS_H + BOX_S_H, X_POS_56 + BOX_S_H, Y_POS_H - BOX_S_H],
    [X_POS_56 - BOX_S_H, Y_POS_16 + BOX_S_H, X_POS_56 + BOX_S_H, Y_POS_16 - BOX_S_H],
    [X_POS_H - BOX_S_H, Y_POS_16 + BOX_S_H, X_POS_H + BOX_S_H, Y_POS_16 - BOX_S_H],
    [X_POS_16 - BOX_S_H, Y_POS_16 + BOX_S_H, X_POS_16 + BOX_S_H, Y_POS_16 - BOX_S_H],
    [X_POS_16 - BOX_S_H, Y_POS_H + BOX_S_H, X_POS_16 + BOX_S_H, Y_POS_H - BOX_S_H]],
    % Inner row
    [[X_POS_26 - BOX_S_H, Y_POS_46 + BOX_S_H, X_POS_26 + BOX_S_H, Y_POS_46 - BOX_S_H],
    [X_POS_H - BOX_S_H, Y_POS_46 + BOX_S_H, X_POS_H + BOX_S_H, Y_POS_46 - BOX_S_H],
    [X_POS_46 - BOX_S_H, Y_POS_46 + BOX_S_H, X_POS_46 + BOX_S_H, Y_POS_46 - BOX_S_H],
    [X_POS_46 - BOX_S_H, Y_POS_H + BOX_S_H, X_POS_46 + BOX_S_H, Y_POS_H - BOX_S_H],
    [X_POS_46 - BOX_S_H, Y_POS_26 + BOX_S_H, X_POS_46 + BOX_S_H, Y_POS_26 - BOX_S_H],
    [X_POS_H - BOX_S_H, Y_POS_26 + BOX_S_H, X_POS_H + BOX_S_H, Y_POS_26 - BOX_S_H],
    [X_POS_26 - BOX_S_H, Y_POS_26 + BOX_S_H, X_POS_26 + BOX_S_H, Y_POS_26 - BOX_S_H],
    [X_POS_26 - BOX_S_H, Y_POS_H + BOX_S_H, X_POS_26 + BOX_S_H, Y_POS_H - BOX_S_H]],
];

%%%%%%%%%%%%%%
% NEIGHBOURS %
%%%%%%%%%%%%%%
const NEIGHBOURS = [
    [[[0, 7], [0, 1]], [[0, 0], [1, 1], [0, 2]],
     [[0, 1], [0, 3]], [[0, 2], [1, 3], [0, 4]],
     [[0, 3], [0, 5]], [[0, 4], [1, 5], [0, 6]],
     [[0, 5], [0, 7]], [[0, 6], [1, 7], [0, 0]]],
    [[[1, 7], [1, 1]], [[1, 0], [0, 1], [2, 1], [1, 2]],
     [[1, 1], [1, 3]], [[1, 2], [0, 3], [2, 3], [1, 4]],
     [[1, 3], [1, 5]], [[1, 4], [0, 5], [2, 5], [1, 6]],
     [[1, 5], [1, 7]], [[1, 6], [0, 7], [2, 7], [1, 0]]],
    [[[2, 7], [2, 1]], [[2, 0], [1, 1], [2, 2]],
     [[2, 1], [2, 3]], [[2, 2], [1, 3], [2, 4]],
     [[2, 3], [2, 5]], [[2, 4], [1, 5], [2, 6]],
     [[2, 5], [2, 7]], [[2, 6], [1, 7], [2, 0]]]
];

% Color data
const HIGHLIGHT_COLOR = [ "RGB", 0.984, 0.800, 0.176 ];

const colors = [
    color.gray,
    color.black
]

% String data
const PLAYER_STR = [
    "Player 1",
    "Player 2"
]

%%%%%%%%%%
% Helper %
%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initialisation and Restart %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/**
 * Initialise the default game state.
 */
function initialise() {
    % Init the GUI
    initialiseButtons();

    refreshGUIstoneCounts();
    drawAll();
}

/**
 * Initialise all buttons from the GUI.
 * For example add callbacks and set the correct colors.
 */
function initialiseButtons() {
    % Assign each button the coresponding function and disable the highlights
    this.getField("restart").setAction("MouseUp", "restart();");
    this.getField("restart").highlight="none";

    % Set the callbacks and attributes of each small field
    var funcName = "place";
    for (var m = 0; m < ROWS; m++) {
        for (var n = 0; n < COLUMNS; n++) {
            var callbackName = funcName + "(" + m.toString() + "," + n.toString() + ");";
            var f = this.getField("pos" + m + "-" + n);
            f.setAction("MouseDown", callbackName);

            f.textSize = TEXT_SIZE;
            f.alignment = "center";

            f.rect = BOX_POSITIONS[m][n];
        }
    }

    % Animation field
    var f = this.getField("animationField");
    f.hidden = true;
    f.textSize = TEXT_SIZE;
    f.alignment = "center";
    f.value = PIECE_SYMBOL;

    % Info field setup
    this.getField("info").fillColor = color.transparent;
    this.getField("info").borderColor = color.transparent;

    % Tooltip setup
    this.getField("tooltipbtn").setAction("MouseDown", "tooltip(true);");
    this.getField("tooltipbtn").setAction("MouseUp", "tooltip(false);");
    this.getField("tooltipbtn").highlight="none";

    printInfoText("Initialised game. " + PLAYER_STR[turn] + ": Your turn!");
}

/**
 * Restart the game and clear everything
 */
function restart() {
    % Reset array to be empty
    for (var m = 0; m < ROWS; m++) {
        for (var n = 0; n < COLUMNS; n++) {
            complField[m][n] = EMPTY;
        }
    }

    % Reset game variables
    gamestate = PLACING;
    gameover = false;
    turn = P_1;
    lastClick = null;
    stonesToPlace = [P_COUNT, P_COUNT];
    stones = [0, 0];

    refreshGUIstoneCounts();
    drawAll();

    printInfoText("Restarted game. " + PLAYER_STR[turn] + " : Your turn!");
}

/**
 * Enable or disable the tooltip
 *
 * @param {Boolean} on Enable or disable tooltip
 */
function tooltip(on) {
    if (on) {
        % Move the tooltip field to the center of the screen
        % and adjust the size so the text can be displayed
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = false;
        field.value = GAME_DESC;

        field.multiline = true;
        field.textSize = 16;
        field.fillColor = color.gray;
        % height 842, width 596
        % upper-left x, upper-left y, lower-right x and lower-right y
        field.rect = [128, 601, 468, 401];

        field.delay = false;
    } else {
        % Remove the field such that it is not visible
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = true;
        field.value = "";

        field.multiline = false;
        field.fillColor = color.gray;
        field.rect = [0, 0, 0, 0];

        field.delay = false;
    }
}

%%%%%%%%%%%%%
% Gamelogic %
%%%%%%%%%%%%%
/**
 * Process user input on a cell according to the game rules.
 * Options are: placing, moving, removing.
 *
 * @param {Number} m The m position.
 * @param {Number} n The n position.
 */
function place(m, n) {
    this.getField("restart").setFocus();
    if (gameover) {
        return;
    }
    if (timestep != 0.0) {
        printInfoText("Please wait for animation.");
        return;
    }

    if (gamestate == PLACING) {
        placing(m, n);
    } else if (gamestate == MOVING) {
        moving(m, n);
    } else if (gamestate == REMOVING) {
        removing(m, n);
    }

    refreshGUIstoneCounts();

    % Check for gameover due to missing pieces or intercepting
    if (stones[P_1] + stonesToPlace[P_1] <= 2 || hasNoMoves(P_1)) {
        gameover = true;
        printInfoText("Game over! Player 2 wins.");
    } else if (stones[P_2] + stonesToPlace[P_2] <= 2 || hasNoMoves(P_2)) {
        gameover = true;
        printInfoText("Game over! Player 1 wins.");
    }
}

/**
 * Places a player stone on the given position.
 * If placeing the stone leads to a mill the removing state
 * is enabled. If there are no further stones to place the
 * moving state is enabled.
 *
 * @param {Number} m The m position.
 * @param {Number} n The n position.
 */
function placing(m, n) {
    if (complField[m][n] != EMPTY) {
        printInfoText(PLAYER_STR[turn] + ": Please select an empty cell!");
        return;
    }
    % Place stone
    complField[m][n] = turn;
    stonesToPlace[turn]--;
    stones[turn]++;

    % Check for mills, if there is one the player is allowed to remove
    % a piece of the enemy
    if (checkMills(m, n)) {
        gamestate = REMOVING;
        printInfoText(PLAYER_STR[turn] + " got a mill, remove an enemy piece!");
    }
    % If there are no further stones to place enable next mode
    else if (stonesToPlace[P_1] <= 0 && stonesToPlace[P_2] <= 0) {
        gamestate = MOVING;
        nextTurn();
        printInfoText(PLAYER_STR[turn] + ": Move your first stone!");
    } else {
        nextTurn();
        printInfoText("Placed a stone! " + PLAYER_STR[turn] + ": Your turn!");
    }
    draw(m, n);
}

/**
 * Processes the given position as a move operation.
 * This must be called twice, once for the source and once for the target position.
 * If the positions are in a neighbourhood or the player has only
 * three stones left the piece is moved.
 * The source piece must be of the player type, while the
 * target position needs to be empty.
 *
 * @param {Number} m The m position.
 * @param {Number} n The n position.
 */
function moving(m, n) {
    if (lastClick != null) {
        % Unselect if clicked on the same cell again
        if (m == lastClick[0] && n == lastClick[1]) {
            % Disable highlight
            highlight(lastClick[0], lastClick[1], false);
            lastClick = null;
            return;
        }
        % The selected cell must be an actual stone
        if (complField[m][n] != EMPTY) {
            printInfoText(PLAYER_STR[turn] + ": Please select an empty position.");
            return;
        }
        % Only allow moves to neighbouring cells, unless the player has 3 pieces left
        if (!isNeighbour(m, n) && (stones[turn] + stonesToPlace[turn] != 3)) {
            printInfoText(PLAYER_STR[turn] + ": Please select a connected position.");
            return;
        }
        % Disable highlight
        highlight(lastClick[0], lastClick[1], false);

        % Start animation
        var callback = "moveAnimation(" + lastClick[0] + "," + lastClick[1] + "," +m+ "," +n+ ")";
        run = app.setInterval(callback, ANIMATION_SPEED);
        lastClick = null;
    } else {
        % Ensure selection of an actuall stone
        if (complField[m][n] == EMPTY) {
            printInfoText(PLAYER_STR[turn] + ": Please select non empty position.");
            return;
        }
        % Ensure selection of own piece
        if (complField[m][n] != turn) {
            printInfoText(PLAYER_STR[turn] + ": Please select one of your own pieces.");
            return;
        }

        highlight(m, n, true);
        lastClick = [m, n];
        printInfoText(PLAYER_STR[turn] + ": Now select position to move to!");
    }
}

/**
 * Function for an animated cell. The cell is moved between two
 * given positions by linear interpolation.
 * The startposition and the center position are redrawn at
 * appropriate times.
 *
 * @param {Number} m1 The source x position.
 * @param {Number} n1 The source y position.
 * @param {Number} m2 The target x position.
 * @param {Number} n2 The target y position.
 */
function moveAnimation(m1, n1, m2, n2) {
    % Get animation cell
    var field = this.getField("animationField");

    % Stop animation and reset if timelimit is reached
    if (timestep >= 1.0) {
        % Redraw
        complField[m2][n2] = turn;
        draw(m2, n2);
        % Check for next state
        if (checkMills(m2, n2)) {
            gamestate = REMOVING;
            printInfoText(PLAYER_STR[turn] + " got a mill, remove an enemy piece!");
        } else {
            nextTurn();
            printInfoText(PLAYER_STR[turn] + ": Your turn to move!");
        }
        % Reset
        timestep = 0.0;
        field.hidden = true;
        app.clearInterval(run);
        return;
    }
    % Draw (remove) the start marble in the beginning
    if (timestep >= 0.0 && timestep <= 0.0 + ANIMATION_OFFSET) {
        field.textColor = colors[turn];

        complField[m1][n1] = EMPTY;
        draw(m1, n1);
    }

    % Show the animation cell
    field.hidden = false;

    % Get the cells for the rectangle
    var src = this.getField("pos" + m1 + "-" + n1);
    var tgt = this.getField("pos" + m2 + "-" + n2);
    % Move the rectangle
    var rect = [0, 0, 0, 0];
    for (var i = 0; i < 4; i++) {
        rect[i] = tgt.rect[i] * timestep + src.rect[i] * (1.0 - timestep);
    }
    field.rect = rect;

    timestep += ANIMATION_OFFSET;
}

/**
 * If the given position contains a piece of the enemy type,
 * the selected piece is removed and the gamestate is reset
 * to either moving or placing.
 *
 * @param {Number} m The m position.
 * @param {Number} n The n position.
 */
function removing(m, n) {
    if (complField[m][n] != turn && complField[m][n] != EMPTY) {
        complField[m][n] = EMPTY;
        nextTurn();
        stones[turn]--;

        % Reset to latest gamestate
        if (stonesToPlace[P_1] <= 0 && stonesToPlace[P_2] <= 0) {
            gamestate = MOVING;
        } else {
            gamestate = PLACING;
        }

        draw(m, n);
        printInfoText("Removed stone! " + PLAYER_STR[turn] + ": Your turn!");
    } else {
        printInfoText(PLAYER_STR[turn] + ": You cant remove your own stone!");
    }
}

/**
 * Checks the neighbourhood of a position for
 * beeing in the vacinity of the lastClick position.

 * @param {Number} m The m position.
 * @param {Number} n The n position.
 * @return {Boolen} True if the position is in the vacinity, else false.
 */
function isNeighbour(m, n) {
    for (var i = 0; i < NEIGHBOURS[m][n].length; i++) {
        var neighbour = NEIGHBOURS[m][n][i];
        if (neighbour[0] == lastClick[0] && neighbour[1] == lastClick[1]) {
            return true;
        }
    }
    return false;
}

/**
 * Checks the given position for beeing part of a mill.

 * @param {Number} m The m position.
 * @param {Number} n The n position.
 * @return {Boolen} True if the position is part of a mill, else false.
 */
function checkMills(m, n) {
    var p = complField[m][n];
    % Check differ depending on arrayposition beeing even or odd
    if (n \% 2 == 0) {
        % Check in a line up and down with m, n beeing at the end of the line
        var n_m2 = (n + 8 - 2) \% 8;
        if (complField[m][n + 1] == p && complField[m][(n + 2) \% 8] == p ||
            complField[m][n_m2 + 1] == p && complField[m][n_m2] == p
        ) {
            return true;
        }
    } else {
        % Check in a line up and down with m, n beeing at the center of the line
        var m_m1 = (m + 3 - 1) \% 3;
        var m_p1 = (m + 1) \% 3;
        if (complField[m][n - 1] == p && complField[m][(n + 1) \% 8] == p ||
            complField[m_m1][n] == p && complField[m_p1][n] == p
        ) {
            return true;
        }
    }

    return false;
}

/**
 * Checks if a given player has any moves left.
 * Iterates all cells and checks its neighbourhood for empty cells.
 * @param {Number} player The player value in the complField.
 * @return {Boolen} True if no moves are left, else false.
 */
function hasNoMoves(player) {
    % If the gamestate is placing the player always has a move left
    if (gamestate == PLACING) {
        return false;
    }

    for (var m = 0; m < ROWS; m++) {
        for (var n = 0; n < COLUMNS; n++) {
            % Check only cells with stones of this player
            if (complField[m][n] != player) {
                continue;
            }
            % Check all neighbours for beeing empty
            for (var i = 0; i < NEIGHBOURS[m][n].length; i++) {
                var neighbour = NEIGHBOURS[m][n][i];
                if (complField[neighbour[0]][neighbour[1]] == EMPTY) {
                    return false;
                }
            }
        }
    }
    return true;
}

function nextTurn() {
    turn = (turn + 1) \% PLAYER_COUNT;
}

%%%%%%%%%%%%%%%%%%%%%
% Draw and coloring %
%%%%%%%%%%%%%%%%%%%%%
/**
 * Redraws the gui elements responsible for displaying
 * the current amounts of stones for each player.
 */
function refreshGUIstoneCounts() {
    var field = this.getField("p1stones");
    field.value = stones[P_1];

    field = this.getField("p1toPlace");
    field.value = stonesToPlace[P_1];

    var field = this.getField("p2stones");
    field.value = stones[P_2];

    field = this.getField("p2toPlace");
    field.value = stonesToPlace[P_2];
}

/**
 * Enables or disables the highlight of the given cell.
 *
 * @param {Number} m The m position.
 * @param {Number} n The n position.
 * @param {Boolean} enable If true enables the highlight
 */
function highlight(m, n, enable) {
    var field = this.getField("pos" + m + "-" + n);
    field.delay = true;
    % Highlight the current taken move
    if (enable) {
        field.borderColor = HIGHLIGHT_COLOR;
    } else {
        field.borderColor = color.gray;
    }
    field.delay = false;
}

/**
 * Draw all fields.
 */
function drawAll() {
    for (var m = 0; m < ROWS; m++) {
        for (var n = 0; n < COLUMNS; n++) {
            draw(m, n);
        }
    }
}

/**
 * Since only one field is updated with each input,
 * only this field needs to be redrawn.
 *
 * @param {Number} m The m position.
 * @param {Number} n The n position.
 */
function draw(m, n) {
    var field = this.getField("pos" + m + "-" + n);
    field.delay = true;
    if (complField[m][n] != EMPTY) {
        field.value = PIECE_SYMBOL;
        field.textColor = colors[complField[m][n]];
    } else {
        field.value = "";
    }
    field.delay = false;
}

/**
 * Print information about the winner and the gamestate.
 */
function printInfoText(text) {
    var field = this.getField("info");
    field.delay = true;
    field.value = text;
    field.delay = false;
}

\end{insDLJS}

\OpenAction{/S /JavaScript /JS (initialise();)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dokument
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

    \begin{Form}

        % Header
        \begin{multicols}{2}
            % Title
            \section*{Mills}
        \columnbreak
            % Tooltip object
            \begin{flushright}%
                \PushButton[name=tooltipbtn, bordercolor=white]{%
                    \begin{tcolorbox}[width=20pt, height=20pt, left=3pt, top=0pt]
                        \centering?\strut{}
                    \end{tcolorbox}%
                }
            \end{flushright}%
        \end{multicols}

        \vspace{0.55cm}

        \begin{center}
            \begin{tikzpicture}
                \def\sizeO{8.7}
                \def\sizeM{6}
                \def\sizeI{3}
                \coordinate (AO) at (-\sizeO,\sizeO);
                \coordinate (BO) at (\sizeO,\sizeO);
                \coordinate (CO) at (\sizeO,-\sizeO);
                \coordinate (DO) at (-\sizeO,-\sizeO);

                \coordinate (AM) at (-\sizeM,\sizeM);
                \coordinate (BM) at (\sizeM,\sizeM);
                \coordinate (CM) at (\sizeM,-\sizeM);
                \coordinate (DM) at (-\sizeM,-\sizeM);

                \coordinate (AI) at (-\sizeI,\sizeI);
                \coordinate (BI) at (\sizeI,\sizeI);
                \coordinate (CI) at (\sizeI,-\sizeI);
                \coordinate (DI) at (-\sizeI,-\sizeI);

                \draw (AO) -- (BO) -- (CO) -- (DO) -- (AO);
                \draw (AM) -- (BM) -- (CM) -- (DM) -- (AM);
                \draw (AI) -- (BI) -- (CI) -- (DI) -- (AI);

                \draw (0, \sizeO) -- (0, \sizeM) -- (0, \sizeI);
                \draw (\sizeO, 0) -- (\sizeM, 0) -- (\sizeI, 0);
                \draw (-\sizeO, 0) -- (-\sizeM, 0) -- (-\sizeI, 0);
                \draw (0, -\sizeO) -- (0, -\sizeM) -- (0, -\sizeI);

            \end{tikzpicture}
        \end{center}

        % The positions of the field
        \xintFor* #1 in {\xintSeq{0}{\rows-1}} \do {%
            \xintFor* #2 in {\xintSeq{0}{\columns-1}} \do {%
                \TextField[name=pos#1-#2, backgroundcolor=white, bordercolor=gray,
                    width=1.0cm, height=1.0cm, readonly=true]{}%
            }
        }%

        %%%%%%%%%%%%%%%%%%%%%%%
        % Commandredifinition %
        % https://www.dickimaw-books.com/latex/admin/html/eforms.shtml
        %%%%%%%%%%%%%%%%%%%%%%%
        \def\DefaultHeightofText{12pt}
        \renewcommand*{\LayoutTextField}[2]{%
            \parbox[c][\DefaultHeightofText]{\DefaultWidthofText}{#1 #2}%
        }

        % GUI
        \begin{center}
            % Game related buttons
            \begin{tabularx}{\textwidth}{@{} *{2}{X} @{}}%
                \begin{tcolorbox}
                    \TextField[name=p1stones, width=0.2\linewidth, charsize=12pt,%
                        bordercolor=, backgroundcolor=, borderwidth=0,%
                        value=0, readonly%
                    ]{P1 stones:\strut}\enspace
                    \TextField[name=p1toPlace, width=0.2\linewidth, charsize=12pt,%
                        bordercolor=, backgroundcolor=, borderwidth=0,%
                        value=0, readonly%
                    ]{to place:\strut}
                \end{tcolorbox} &
                \begin{tcolorbox}
                    \TextField[name=p2stones, width=0.2\linewidth, charsize=12pt,%
                        bordercolor=, backgroundcolor=, borderwidth=0,%
                        value=0, readonly%
                    ]{P2 stones:\strut}\enspace
                    \TextField[name=p2toPlace, width=0.2\linewidth, charsize=12pt,%
                        bordercolor=, backgroundcolor=, borderwidth=0,%
                        value=0, readonly%
                    ]{to place:\strut}
                \end{tcolorbox} \\%
                \PushButton[name=restart, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        Restart game\strut
                    \end{tcolorbox}
                } &
                \begin{tcolorbox}
                    \TextField[name=info, width=2\linewidth, readonly=true]{}
                \end{tcolorbox}
            \end{tabularx}
        \end{center}

        \TextField[name=animationField, backgroundcolor=, bordercolor=,
            width=1.0cm, height=1.0cm, readonly=true]{}%
        \TextField[bordercolor=white, name=tooltiptxt, readonly=true, hidden]{}

    \end{Form}
\end{document}
