\documentclass[12pt, a4paper, footexclude, headexclude]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[margin=0.5in]{geometry}

\usepackage[pdftex]{hyperref}
\usepackage{multicol}

\usepackage{xinttools}
\usepackage{tabularx}
\usepackage{tcolorbox}

\setlength{\parindent}{0pt}

\usepackage[pdftex]{insdljs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\cards{32}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Javascript
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{insDLJS}[]{JSDateiname}{Maumau}

const GAME_DESC = "Text.\
Text.\
Text.\
Text.\
Text.";

% Outside variables
const CARD_COUNT = AFMakeNumber(\cards);
const ANIMATION_SPEED = 50;

% Constants
const TEXT_SIZE = 14;

% Access constants
const X = 0;
const Y = 1;
const SYMB = 2;
const LEFT = 0;
const TOP = 1;
const RIGHT = 2;
const BOT = 3;
% Document dims: 842, 596
% Canvas dims
% upper-left x, upper-left y, lower-right x and lower-right y
const CANVAS_LTRB = [47.5, 765, 547.5, 256];
const CANVAS_HEIGHT = CANVAS_LTRB[TOP] - CANVAS_LTRB[BOT];
const CANVAS_WIDTH = CANVAS_LTRB[RIGHT] - CANVAS_LTRB[LEFT];
const CANVAS_CENTER_H = CANVAS_HEIGHT * 0.5 + CANVAS_LTRB[BOT];
const CANVAS_CENTER_W = CANVAS_WIDTH * 0.5 + CANVAS_LTRB[LEFT];

const CARD_WIDTH = 20;
const STACK_POS = [CANVAS_CENTER_W - CARD_WIDTH * 1.25, CANVAS_CENTER_H];
const GRAVE_POS = [CANVAS_CENTER_W + CARD_WIDTH * 1.25, CANVAS_CENTER_H];
const SKIP_POS = [CANVAS_CENTER_W, CANVAS_CENTER_H + CARD_WIDTH * 2.5];

const PLAYER_POS = [
    [CANVAS_LTRB[LEFT] + CARD_WIDTH * 2.0, CANVAS_LTRB[BOT] + CARD_WIDTH],
    [CANVAS_LTRB[LEFT] + CARD_WIDTH, CANVAS_LTRB[BOT] + CARD_WIDTH * 2.0],
    [CANVAS_LTRB[LEFT] + CARD_WIDTH * 2.0, CANVAS_LTRB[TOP] - CARD_WIDTH],
    [CANVAS_LTRB[RIGHT] - CARD_WIDTH, CANVAS_LTRB[BOT] + CARD_WIDTH * 2.0]
]

% Globals
% TODO
var gameInterval;
% Saves the index of the currently used card
var curCardIdx = -1;
% The playercount is read from the gui
var playerCount = 0;
% The cards per player is read from the gui
var cardsPerPlayer = 0;
% Saves which turn it is
var curPlayer = 0;
% Player cards
var playerCards = [
    [], [], [], []
];
% Used to rotate the shown cards in the direction of the player
% The first two slots are padding to allow the use of the cardOwner index
var rotations = [0, 0, 0, 270, 180, 90];

% Information about the gamestate and special rules
var gameState = {
    gameover: true,
    skip8: false,
    take: 0,
    taking: false,
    selColor: false
};

% Spades, clubs, hearts, diamonds
% const CARD_COLORS = ["S", "C", "H", "D"];
const CARD_COLORS = [
    String.fromCharCode(0x2660),
    String.fromCharCode(0x2663),
    String.fromCharCode(0x2665),
    String.fromCharCode(0x2666)
];

const CARD_VALUES = ["7", "8", "9", "10", "J", "Q", "K", "A"];
const CARDS = [];

var graveyard = [];
var stack = [];

const STACK = -1;
const GRAVEYARD = -2;
var cardOwner = [];

for (var col = 0; col < CARD_COLORS.length; col++) {
    for (var val = 0; val < CARD_VALUES.length; val++) {
        CARDS.push(CARD_VALUES[val] + CARD_COLORS[col]);
    }
}

var rules = {
    cb7: true,
    cb7chain: true,
    cb8: true,
    cb8chain: true,
    cb9: false,
    cb10: false,
    cbJ: true,
    cbJchain: false,
    cbK: false,
    cbKchain: false,
    cbAcard: false,
    cbAskip: false
};

%%%%%%%%%%
% Helper %
%%%%%%%%%%
/**
 * Returns a random integer between 0 and the param.
 * @param {Number} max The upperbound.
 */
function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initialisation and Restart %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/**
 * Initialise the default game state.
 */
function initialise() {
    % Init the GUI
    initialiseButtons();

    % Init unused cards
    for (var i = 0; i < CARD_COUNT; i++) {
        graveyard.push(i);
    }
    for (var i = 0; i < CARD_COUNT; i++) {
        % Get random element from the  and remove the card afterwards
        var rnd = getRandomInt(graveyard.length);
        stack.push(graveyard[rnd]);
        cardOwner.push(STACK);
        graveyard.splice(rnd, 1);
    }

    curCardIdx = stack.length - 1;
    gameInterval = app.setInterval("initStack()", ANIMATION_SPEED);
}

/**
 * Initialise all buttons from the GUI.
 * For example add callbacks and set the correct colors.
 */
function initialiseButtons() {
    % Disables the rectangle around a button after the click
    app.focusRect = false;

    % Init player count
    var cmP = this.getField("cmPlayer");
    cmP.checkThisBox(2);
    playerCount = 0;
    for (var i = 0; i < 3; i++) {
        playerCount += cmP.isBoxChecked(i) * (2 + i);
    };

    % Init cards per player count
    var cmC = this.getField("cmCards");
    cmC.checkThisBox(1);
    for (var i = 0; i < 5; i++) {
        cardsPerPlayer += cmC.isBoxChecked(i) * (4 + i);
    };

    for (var c = 0; c < CARDS.length; c++) {
        var callbackName = "chooseCard(" + c.toString() + ");";
        var card = this.getField("card" + c);
        card.delay = true;
        card.setAction("MouseUp", callbackName);
        if (c >= CARDS.length * 0.5) {
            card.textColor = color.red;
        }
        card.textFont = font.Cour;
        card.textSize = TEXT_SIZE;
        card.alignment = "center";
        card.delay = false;
    }

    % Skip button
    var skipBtn = this.getField("skip");
    skipBtn.delay = true;
    skipBtn.setAction("MouseUp", "skip();");
    skipBtn.rect = [
        SKIP_POS[X] - CARD_WIDTH - CARD_WIDTH * 1.25,
        SKIP_POS[Y] + CARD_WIDTH,
        SKIP_POS[X] + CARD_WIDTH + CARD_WIDTH * 1.25,
        SKIP_POS[Y] - CARD_WIDTH
    ];
    skipBtn.textFont = font.Cour;
    skipBtn.textSize = TEXT_SIZE;
    skipBtn.alignment = "center";
    skipBtn.value = "Skip turn";
    skipBtn.hidden = false;
    skipBtn.delay = false;

    % Copy rules to the gui by iterating all keys of the rules object
    var cbKeys = Object.keys(rules);
    for (var idx = 0; idx < cbKeys.length; idx++) {
        if (rules[cbKeys[idx]] == true) {
            var cb = this.getField(cbKeys[idx]);
            cb.checkThisBox(0);
        }
    }

    % Assign each button the coresponding function and disable the highlights
    this.getField("restart").setAction("MouseUp", "restart();");

    % Info field setup
    this.getField("info").fillColor = color.transparent;
    this.getField("info").borderColor = color.transparent;

    % Tooltip setup
    this.getField("tooltipbtn").setAction("MouseDown", "tooltip(true);");
    this.getField("tooltipbtn").setAction("MouseUp", "tooltip(false);");

    printInfoText("Init");
}

/**
 * Restart the game and clear everything
 */
function restart() {
    gameState.gameover = true;
    curPlayer = 0;
    playerCards = [
        [], [], [], []
    ];

    graveyard = [];
    stack = [];

    for (var i = 0; i < CARD_COUNT; i++) {
        graveyard.push(i);
    }
    for (var i = 0; i < CARD_COUNT; i++) {
        % Get random element from the  and remove the card afterwards
        var rnd = getRandomInt(graveyard.length);
        stack.push(graveyard[rnd]);
        cardOwner[i] = STACK;
        graveyard.splice(rnd, 1);
    }

    for (var c = 0; c < CARDS.length; c++) {
        var card = this.getField("card" + c);
        card.hidden = true;
    }

    % Init player count
    var cmP = this.getField("cmPlayer");
    playerCount = 0;
    for (var i = 0; i < 3; i++) {
        playerCount += cmP.isBoxChecked(i) * (2 + i);
    };

    % Init cards per player count
    cardsPerPlayer = 0;
    var cmC = this.getField("cmCards");
    for (var i = 0; i < 5; i++) {
        cardsPerPlayer += cmC.isBoxChecked(i) * (4 + i);
    };

    % Get rules from gui by iterating all keys of the rules object
    var cbKeys = Object.keys(rules);
    for (var idx = 0; idx < cbKeys.length; idx++) {
        var cb = this.getField(cbKeys[idx]);
        % Convert to boolean
        rules[cbKeys[idx]] = cb.isBoxChecked(0) == 1;
    }

    if (cardsPerPlayer > 0) {
        curCardIdx = stack.length - 1;
        gameInterval = app.setInterval("initStack()", ANIMATION_SPEED);

        printInfoText("Restarted the game. You turn player " + (curPlayer + 1) + ".");
    } else {
        printInfoText("Choose the amount of cards each player should have.");
    }
}

/**
 * Enable or disable the tooltip
 *
 * @param {Boolean} on Enable or disable tooltip
 */
function tooltip(on) {
    if (on) {
        % Move the tooltip field to the center of the screen
        % and adjust the size so the text can be displayed
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = false;
        field.value = GAME_DESC;

        field.multiline = true;
        field.textSize = 16;
        field.fillColor = color.gray;
        % height 842, width 596
        % upper-left x, upper-left y, lower-right x and lower-right y
        field.rect = [128, 601, 468, 401];

        field.delay = false;
    } else {
        % Remove the field such that it is not visible
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = true;
        field.value = "";

        field.multiline = false;
        field.fillColor = color.gray;
        field.rect = [0, 0, 0, 0];

        field.delay = false;
    }
}

%%%%%%%%%%%%%
% Gamelogic %
%%%%%%%%%%%%%
% 1. Drop cards
% 2. Deploy cards
% 3. Open first card
% 4.1 if card on hand is clicked play it
% 4.2 if card on stack is clicked take it

% TODOs
% buttons for mau und maumau
% animations
% special card rules

function chooseCard(cardIdx) {
    this.getField("tooltiptxt").setFocus();

    if (gameState.gameover) {
        printInfoText("Game is over or the new Game is not ready yet.");
        return;
    }

    if (!specialRulesBegin(cardIdx)) {
        return;
    }

    % Player draws a card
    if (cardOwner[cardIdx] == STACK) {
        var card = this.getField("card" + stack[0]);
        cardOwner[stack[0]] = curPlayer;

        playerCards[curPlayer].push(stack[0]);

        redrawPlayerCards(curPlayer);

        stack.splice(0, 1);

        if (stack.length <= 0) {
            for (var i = 0; i < graveyard.length - 1; i++) {
                stack.push(graveyard[i]);
                cardOwner[graveyard[i]] = STACK;
            }
            graveyard.splice(0, graveyard.length - 1);
            curCardIdx = stack.length - 1;
            gameInterval = app.setInterval("initStack()", ANIMATION_SPEED);
        } else {
            printInfoText("Player " + (curPlayer + 1) + " took a card!");
        }

        specialRulesDraw();

    } else if (cardOwner[cardIdx] > STACK) {
        if (cardOwner[cardIdx] != curPlayer) {
            printInfoText(
                "Its not your turn Player " + (cardOwner[cardIdx] + 1) + "!" +
                " Your turn Player " + (curPlayer + 1) + ".");
            return;
        }

        if (!validMove(cardIdx)) {
            printInfoText("This is not a valid move, select another card!");
            return;
        }

        % Hide last top card
        var tmpIdx = graveyard[graveyard.length - 1];
        var topCard = this.getField("card" + tmpIdx);
        topCard.hidden = true;

        % Put selected card on the graveyard
        cardOwner[cardIdx] = GRAVEYARD;
        graveyard.push(cardIdx);
        const index = playerCards[curPlayer].indexOf(cardIdx);
        playerCards[curPlayer].splice(index, 1);

        var card = this.getField("card" + cardIdx);
        card.delay = true;
        card.rect = [
            GRAVE_POS[X] - CARD_WIDTH,
            GRAVE_POS[Y] + CARD_WIDTH,
            GRAVE_POS[X] + CARD_WIDTH,
            GRAVE_POS[Y] - CARD_WIDTH
        ];
        card.delay = false;

        drawCardFront(cardIdx);
        redrawPlayerCards(curPlayer);

        if (playerCards[curPlayer].length <= 0) {
            gameState.gameover = true;
            printInfoText("Player " + (curPlayer + 1) + " has no cards left and won the game!");
            return;
        } else {
            printInfoText("Player " + (curPlayer + 1) + " played a card!");
        }

        specialRulesPlay(cardIdx);
    } else {
        return;
    }

    curPlayer = (curPlayer + 1) \% playerCount;
}

function validMove(cardIdx) {
    const topGraveIdx = graveyard[graveyard.length - 1];
    const c1 = CARDS[topGraveIdx];
    const c2 = CARDS[cardIdx];
    const l1 = c1.length;
    const l2 = c2.length;

    % Test if card has same number or color as the top graveyard card
    % Exception if enabled: all-rounder 9
    if (c1.charAt(l1 - 2) == c2.charAt(l2 - 2) ||
        c1.charAt(l1 - 1) == c2.charAt(l2 - 1) ||
        rules.cb9 && c2.charAt(0) == "9"
    ) {
        return true;
    }
    return false;
}

function skip() {
    if (gameState.skip8) {
        printInfoText("Player " + (curPlayer + 1) + " is skipped.");
        curPlayer = (curPlayer + 1) \% playerCount;
        gameState.skip8 = false;
    } else {
        printInfoText("You can not skip!");
    }
}

% Rules: https://en.wikipedia.org/wiki/Mau-Mau_(card_game)
function specialRulesBegin(cardIdx) {
    % Get top card value (graveyard card)
    const gC = CARDS[graveyard[graveyard.length - 1]];
    % Get playing Card
    const pC = CARDS[cardIdx];

    % If a take card was played
    if (gameState.take > 0) {
        % If chaining is allowed, check if correct card was played
        % and the player has not already started drawing cards
        if (rules.cb7chain && !gameState.taking && pC.charAt(0) == "7" && gC.charAt(0) == "7" ||
            rules.cbKchain && !gameState.taking && pC.charAt(0) == "K" && gC.charAt(0) == "K"
        ) {
            return true;
        }
        % If chaining is disabled, or the card is not valid the player needs to draw
        else {
            if (cardOwner[cardIdx] == STACK) {
                gameState.take--;
                gameState.taking = true;
                printInfoText("Player " + (curPlayer + 1) + " took a card! " +
                    gameState.take + " cards left.");
                return true;
            } else {
                printInfoText("Player " + (curPlayer + 1) + " you still have " +
                    gameState.take + " cards to draw!");
                return false;
            }
        }
    }

    % If a not processed eight was played last and chaining is allowed
    % allow the player to play an eight
    if (gameState.skip8) {
        if (pC.charAt(0) == "8") {
            return true;
        } else {
            printInfoText("Player " + (curPlayer + 1) + ", that is not a valid move!");
            return false;
        }
    }
    return true;
}

function specialRulesDraw() {
    if (gameState.take > 0) {
        curPlayer--;
    }
}

function specialRulesPlay(cardIdx) {
    % Get top card value
    const c = CARDS[cardIdx];
    const l = c.length;

    % Adjust take count for next player
    if (rules.cb7 && c.charAt(0) == "7") {
        gameState.taking = false;
        gameState.take += 2;
    }
    % Skip player when played an eight
    else if (rules.cb8 && c.charAt(0) == "8") {
        if (rules.cb8chain) {
            gameState.skip8 = true;
            printInfoText("Player " + (curPlayer + 2) + ", play 8 or skip.");
        } else {
            curPlayer = (curPlayer + 1) \% playerCount;
            printInfoText("Player " + (curPlayer + 1) + " is skipped.");
        }
    }
    % Adjust take count for next player
    else if (rules.cbK && c.charAt(0) == "K") {
        gameState.taking = false;
        gameState.take += 4;
    }
    % Skip player when played an ass
    else if (rules.cbAskip && c.charAt(0) == "A") {
        curPlayer = (curPlayer + 1) \% playerCount;
        printInfoText("Player " + (curPlayer + 1) + " is skipped. ");
    }
    % Get another turn when played an ass
    else if (rules.cbAcard && c.charAt(0) == "A") {
        printInfoText("Player " + (curPlayer + 1) + " has played an ass and must play another card.");
        curPlayer--;
    }
}

function openFirstCard() {
    cardOwner[stack[0]] = GRAVEYARD;
    graveyard.push(stack[0]);
    var card = this.getField("card" + stack[0]);
    card.delay = true;
    card.rect = [
        GRAVE_POS[X] - CARD_WIDTH,
        GRAVE_POS[Y] + CARD_WIDTH,
        GRAVE_POS[X] + CARD_WIDTH,
        GRAVE_POS[Y] - CARD_WIDTH
    ];
    card.delay = false;

    drawCardFront(stack[0]);
    stack.splice(0, 1);

    gameState.gameover = false;
    printInfoText("The game has started. Player " + (curPlayer + 1) + " your Turn.");
}

%%%%%%%%%%%%%%%%%%%%%
% Draw and coloring %
%%%%%%%%%%%%%%%%%%%%%
function initStack() {
    if (curCardIdx < 0) {
        app.clearInterval(gameInterval);

        if (gameState.gameover) {
            gameInterval = app.setInterval("initHandCards()", ANIMATION_SPEED * 3.0);
            curCardIdx = playerCount * cardsPerPlayer - 1;
        }
        return;
    }

    var idx = stack[curCardIdx];
    var card = this.getField("card" + idx);
    card.hidden = false;

    var offset = [-5 + getRandomInt(11), -5 + getRandomInt(11)];

    card.rect = [
        STACK_POS[X] - CARD_WIDTH + offset[X],
        % STACK_POS[X] - CARD_WIDTH + curCardIdx * 30,
        % STACK_POS[X] * 0.5 - CARD_WIDTH + curCardIdx * 10,
        STACK_POS[Y] + CARD_WIDTH + offset[Y],
        STACK_POS[X] + CARD_WIDTH + offset[X],
        % STACK_POS[X] + CARD_WIDTH + curCardIdx * 30,
        % STACK_POS[X] * 0.5 + CARD_WIDTH + curCardIdx * 10,
        STACK_POS[Y] - CARD_WIDTH + offset[Y]
    ];

    drawCardBack(stack[curCardIdx]);

    curCardIdx--;
}

function initHandCards() {
    if (curCardIdx < 0) {
        app.clearInterval(gameInterval);

        % Place top card of stack on graveyard
        openFirstCard();

        return;
    }

    var card = this.getField("card" + stack[0]);
    cardOwner[stack[0]] = curPlayer;
    playerCards[curPlayer].push(stack[0]);
    redrawPlayerCards(curPlayer);
    stack.splice(0, 1);
    curPlayer = (curPlayer + 1) \% playerCount;

    curCardIdx--;
}

function drawCardFront(cardIdx) {
    var card = this.getField("card" + cardIdx);
    card.delay = true;
    card.fillColor = color.white;
    card.value = CARDS[cardIdx];
    card.rotation = rotations[cardOwner[cardIdx] + 2];
    card.delay = false;
}

function drawCardBack(cardIdx) {
    var card = this.getField("card" + cardIdx);
    card.delay = true;
    card.fillColor = color.blue;
    card.value = "";
    card.delay = false;
}

function redrawPlayerCards(pIdx) {
    playerCards[pIdx].sort(function(a, b) {
        return a - b;
    });

    var perCardH = (CANVAS_HEIGHT - CARD_WIDTH * 4.0) / playerCards[pIdx].length;
    var perCardW = (CANVAS_WIDTH - CARD_WIDTH * 4.0) / playerCards[pIdx].length;
    var cardWidth = Math.min(CARD_WIDTH, perCardH * 0.5 - 2);
    if (pIdx \% 2 == 0) {
        cardWidth = Math.min(CARD_WIDTH, perCardW * 0.5 - 2);
    }

    for (var c = 0; c < playerCards[pIdx].length; c++) {
        var pos = playerCards[pIdx].length * 0.5 - c;

        var cardIdx = playerCards[pIdx][c];
        var card = this.getField("card" + cardIdx);
        card.delay = true;
        if (pIdx \% 2 == 0) {
            card.rect = [
                PLAYER_POS[pIdx][X] - cardWidth + c * perCardW + perCardW * 0.5,
                PLAYER_POS[pIdx][Y] + cardWidth,
                PLAYER_POS[pIdx][X] + cardWidth + c * perCardW + perCardW * 0.5,
                PLAYER_POS[pIdx][Y] - cardWidth
            ];
        } else {
            card.rect = [
                PLAYER_POS[pIdx][X] - cardWidth,
                PLAYER_POS[pIdx][Y] + cardWidth + c * perCardH + perCardH * 0.5,
                PLAYER_POS[pIdx][X] + cardWidth,
                PLAYER_POS[pIdx][Y] - cardWidth + c * perCardH + perCardH * 0.5
            ];
        }
        card.delay = false;

        drawCardFront(cardIdx);
    }
}

/**
 * Print information about the winner and the gamestate.
 */
function printInfoText(text) {
    var field = this.getField("info");
    field.delay = true;
    field.value = text;
    field.delay = false;
}

\end{insDLJS}

\OpenAction{/S /JavaScript /JS (initialise();)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dokument
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

    \begin{Form}

        % Header
        \begin{multicols}{2}
            % Title
            \section*{Mau mau}
        \columnbreak
            % Tooltip object
            \begin{flushright}%
                \PushButton[name=tooltipbtn, bordercolor=white]{%
                    \begin{tcolorbox}[width=20pt, height=20pt, left=3pt, top=0pt]
                        \centering?\strut{}
                    \end{tcolorbox}%
                }
            \end{flushright}%
        \end{multicols}

        \begin{tcolorbox}[height=\linewidth, valign=center]
            \xintFor* #1 in {\xintSeq{0}{\cards-1}} \do {%
                \TextField[name=card#1, width=1cm, height=1cm,%
                    bordercolor=gray, backgroundcolor=white, readonly=true, hidden%
                ]{}%
            }%

            \TextField[name=skip, width=1cm, height=1cm,%
                bordercolor=gray, backgroundcolor=white, readonly=true, hidden]{}%
        \end{tcolorbox}

        %%%%%%%%%%%%%%%%%%%%%%%
        % Commandredifinition %
        % https://www.dickimaw-books.com/latex/admin/html/eforms.shtml
        %%%%%%%%%%%%%%%%%%%%%%%
        % \def\DefaultHeightofText{14pt}
        % \renewcommand*{\LayoutTextField}[2]{%
        %     \parbox[c][\DefaultHeightofText]{0.5\linewidth}{#1#2}%
        % }

        \renewcommand*{\LayoutCheckField}[2]{#2 #1}
        \renewcommand*{\DefaultWidthofCheckBox}{2ex}
        \renewcommand*{\DefaultHeightofCheckBox}{2ex}
        \renewcommand*{\LayoutCheckField}[2]{%
            \parbox[c][\DefaultHeightofCheckBox]{\DefaultWidthofCheckBox}{#2}\enspace%
            \parbox[c][\DefaultHeightofCheckBox]{\linewidth}{#1}%
        }

        \renewcommand*{\DefaultWidthofChoiceMenu}{2.5ex}
        \renewcommand*{\DefaultHeightofChoiceMenu}{2.04ex}

        %%%%%%%%%%%%%%%%
        % GUI elements %
        %%%%%%%%%%%%%%%%
        \begin{center}
            % Game related buttons
            \begin{tabularx}{\textwidth}{@{} *{2}{X} @{}}%
                \PushButton[name=restart, bordercolor=white, borderwidth=0]{
                    \begin{tcolorbox}
                        \centering
                        Restart game\strut
                    \end{tcolorbox}
                } &
                \begin{tcolorbox}
                    \TextField[name=info, width=\linewidth, readonly=true]{}
                \end{tcolorbox}
            \end{tabularx}
        \end{center}
        \vspace{-1cm}
    \subsection*{Rules}
        The game needs to be restarted for changes to take effect.

        \ChoiceMenu[name=cmPlayer, bordercolor=gray, radiosymbol=5, radio]
            {Player Count: }{2, 3, 4}\hfill
        \ChoiceMenu[name=cmCards, bordercolor=gray, radiosymbol=5, radio]
            {Player card count: }{4, 5, 6, 7, 8}

        \begin{center}
            \begin{tabularx}{\textwidth}{@{} X X @{}}
                \CheckBox[name=cb7, bordercolor=gray, checkboxsymbol=5]{7: take 2} &%
                \CheckBox[name=cb7chain, bordercolor=gray, checkboxsymbol=5]{7: chaining}
                \\%
                \CheckBox[name=cb8, bordercolor=gray, checkboxsymbol=5]{8: skip player} &%
                \CheckBox[name=cb8chain, bordercolor=gray, checkboxsymbol=5]{8: chaining}
                \\%
                \CheckBox[name=cb9, bordercolor=gray, checkboxsymbol=5]{9: all-rounder} &%
                \CheckBox[name=cb10, bordercolor=gray, checkboxsymbol=5]{10: change direction}
                \\%
                \CheckBox[name=cbJ, bordercolor=gray, checkboxsymbol=5]{Jack: select color} &%
                \CheckBox[name=cbJchain, bordercolor=gray, checkboxsymbol=5]{Jack: chaining}
                \\%
                \CheckBox[name=cbK, bordercolor=gray, checkboxsymbol=5]{King: take 4} &%
                \CheckBox[name=cbKchain, bordercolor=gray, checkboxsymbol=5]{King: chaining}
                \\%
                \CheckBox[name=cbAcard, bordercolor=gray, checkboxsymbol=5]{Ace: play another card} &%
                \CheckBox[name=cbAskip, bordercolor=gray, checkboxsymbol=5]{Ace: skip player}
                %
            \end{tabularx}
        \end{center}

        \TextField[bordercolor=white, name=tooltiptxt, readonly=true, hidden]{}

    \end{Form}
\end{document}
