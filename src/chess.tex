\documentclass[12pt, a4paper, footexclude, headexclude]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[margin=0.5in]{geometry}

% \usepackage[utf8x]{inputenc}
% \usepackage[T1]{fontenc}
% \usepackage[ngerman]{babel}
% \usepackage{xcolor}
\usepackage[pdftex]{hyperref}
\usepackage{multicol}

\usepackage{xinttools}
\usepackage[nomessages]{fp}
\usepackage{tabularx}
\usepackage{tcolorbox}

\setlength{\parindent}{0pt}

\usepackage[pdftex]{insdljs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\fieldWidth{8}
\def\fieldHeight{8}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Javascript
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{insDLJS}[]{JSDateiname}{chess}

const GAME_DESC = "Text.\
Text.\
Text.\
Text.\
Text.";

% Outside variables
const FIELD_WIDTH = AFMakeNumber(\fieldWidth);
const FIELD_HEIGHT = AFMakeNumber(\fieldHeight);

% Constants
const M = 0;
const N = 1;
%
const PICE = 0;
const EMPTY = "";
%
const COLOR = 1;
const WHITE = -1;
const NONE = 0;
const BLACK = 1;
%
const STATE = 2;
const UNMOVED = 0;
const MOVED = 1;

% Globals
% The game field array
var complField = new Array();
%
var checkmate = false;
%
var check = false;
%
var lastSelection = [];
%
var currentTurn = WHITE;

% Color data
const COLORS = new Array(
    color.white,
    color.black
);

% Highlightcolor for selection
const SELECTION_COLOR = [ "RGB", 0.984, 0.800, 0.176 ];
% Highlightcolor for possible moves
const POSS_MOVE_COLOR = [ "RGB", 0.54, 0.800, 0.176 ];

%%%%%%%%%%
% Helper %
%%%%%%%%%%
/**
 * Returns a random number between 0 and the param.
 * @param {Number} max The upperbound
 */
function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initialisation and Restart %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/**
 * Initialise the default game state.
 */
function initialise() {
    % Fill the array with the default content and infos
    for (var m = 0; m < FIELD_HEIGHT; m++) {
        var row = new Array();
        for (var n = 0; n < FIELD_WIDTH; n++) {
            row.push([EMPTY, NONE, UNMOVED]);
        }
        complField.push(row);
    }

    addPices();

    % Init the GUI
    initialiseButtons();

    drawAll();
    printInfoText("Ready to play, good luck.");
}

/**
 * Initialise all buttons from the GUI.
 * For example add callbacks and set the correct colors.
 */
function initialiseButtons() {
    % Disables the rectangle around a button after the click
    app.focusRect = false;

    % Set the callbacks and attributes of each small field
    var funcName = "move";
    for (var m = 0; m < FIELD_WIDTH; m++) {
        for (var n = 0; n < FIELD_HEIGHT; n++) {
            var callbackName = funcName + "(" + m.toString() + "," + n.toString() + ");";
            var c = this.getField("cell" + m + "-" + n);
            c.setAction("MouseDown", callbackName);
            c.alignment = "center";
            c.borderWidth = 5;
        }
    }

    % Restat button setup
    this.getField("restart").setAction("MouseDown", "restart();");

    % Info field setup
    this.getField("info").fillColor = color.transparent;
    this.getField("info").borderColor = color.transparent;

    % Tooltip button setup
    this.getField("tooltipbtn").setAction("MouseDown", "tooltip(true);");
    this.getField("tooltipbtn").setAction("MouseUp", "tooltip(false);");
}

/**
 * Restart the game by reseting everything to default.
 */
function restart() {
    % Remove focus so the cursor is not shown
    this.getField("info").setFocus();

    check = false;
    checkmate = false;

    % Clear the field
    for (var m = 2; m < FIELD_HEIGHT - 2; m++) {
        for (var n = 0; n < FIELD_WIDTH; n++) {
             complField[m][n] = [EMPTY, NONE, UNMOVED];
        }
    }

    addPices();

    drawAll();
    printInfoText("Restarted the game.");
}

function addPices() {
    % Init pawns
    for (var n = 0; n < FIELD_WIDTH; n++) {
        complField[1][n] = ["P", BLACK, UNMOVED];
        complField[FIELD_HEIGHT - 2][n] = ["P", WHITE, UNMOVED];
    }

    % Init ROOKS, KNIGHT, BISHOP
    const PICES = ["R", "N", "B"];
    for (var n = 0; n < PICES.length; n++) {
        complField[0][n] = [PICES[n], BLACK, UNMOVED];
        complField[0][FIELD_WIDTH - n - 1] = [PICES[n], BLACK, UNMOVED];
        complField[FIELD_HEIGHT - 1][n] = [PICES[n], WHITE, UNMOVED];
        complField[FIELD_HEIGHT - 1][FIELD_WIDTH - n - 1] = [PICES[n], WHITE, UNMOVED];
    }

    complField[0][3] = ["Q", BLACK, UNMOVED];
    complField[0][4] = ["K", BLACK, UNMOVED];
    complField[FIELD_HEIGHT - 1][3] = ["Q", WHITE, UNMOVED];
    complField[FIELD_HEIGHT - 1][4] = ["K", WHITE, UNMOVED];
}

/**
 * Enable or disable the tooltip
 *
 * @param {Boolean} on Enable or disable tooltip
 */
function tooltip(on) {
    if (on) {
        % Move the tooltip field to the center of the screen
        % and adjust the size so the text can be displayed
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = false;
        field.value = GAME_DESC;

        field.multiline = true;
        field.textSize = 16;
        field.fillColor = color.gray;
        % height 842, width 596
        % upper-left x, upper-left y, lower-right x and lower-right y
        field.rect = [128, 601, 468, 401];

        field.delay = false;
    } else {
        % Remove the field such that it is not visible
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = true;
        field.value = "";

        field.multiline = false;
        field.fillColor = color.gray;
        field.rect = [0, 0, 0, 0];

        field.delay = false;
    }
}

%%%%%%%%%%%%%
% Gamelogic %
%%%%%%%%%%%%%

function move(m, n) {
    this.getField("tooltiptxt").setFocus();

    % If no selection was made, save this press and show potential destinations
    if (lastSelection.length == 0) {
        if (validSelection(m, n)) {
            lastSelection = [m, n];
            % Highlight selection
            highlight(m, n, SELECTION_COLOR, true);
            % Highlight possible moves
            highlightValidMoves(true);
            printInfoText("Pice selected.");
        }
    }
    % If a selection is already saved check if the move is valid and if so move the piece there
    else if (validMove(m, n)) {
        % Remove selection highlight
        highlight(m, n, 0, false);
        % Remove highlight of possible moves
        highlightValidMoves(false);

        complField[m][n] = complField[lastSelection[M]][lastSelection[N]];
        complField[m][n][STATE] = MOVED;
        complField[lastSelection[M]][lastSelection[N]] = [EMPTY, NONE, UNMOVED];

        draw(m, n);
        draw(lastSelection[M], lastSelection[N]);

        if (currentTurn == WHITE) {
            currentTurn = BLACK;
        } else {
            currentTurn = WHITE;
        }

        lastSelection = [];
        printInfoText("Piece moved!");
    } else if (lastSelection[M] == m && lastSelection[N] == n) {
        % Remove selection highlight
        highlight(m, n, 0, false);
        % Remove highlight of possible moves
        highlightValidMoves(false);
        lastSelection = [];
        printInfoText("Unselected pice.");
    }
}

function validSelection(m, n) {
    if (complField[m][n][PICE] == EMPTY) {
        printInfoText("Field empty, could not select!");
        return false;
    } else if (currentTurn != complField[m][n][COLOR]) {
        printInfoText("Thats an enemy pice, could not select!");
        return false;
    }

    return true;
}

% One could also save the valid moves after marking them or one could check
% If the border color of the cell is identical with the POSS_MOVE_COLOR, but
% since it is unclear whether a cell lookup and comparison is faster then
% simply checking the math, the latter solution was used.

/**
 * To check if a move is valid the bordercolor of the target field that was selected is
 * checked, since it should be marked with POSS_MOVE_COLOR if the move would be valid.
 * It is not totally clear whether that is faster than just using math to check the
 * validity but since it also would be necessary to check if there is a pice between
 * source and target this approach at least saves a few lines of duplicated code.
 */
function validMove(m, n) {
    % TODO path must be free, check for that
    if (currentTurn == complField[m][n][COLOR]) {
        printInfoText("Move not valid, thats your own pice!");
        return false;
    }

    % Retrieve the field data
    var cell = this.getField("cell" + m + "-" + n);
    if (cell.borderColor == POSS_MOVE_COLOR) {
        return true;
    } else {
        printInfoText(complField[lastSelection[M]][lastSelection[N]][PICE] + " can not move there.");
        return false;
    }


    % Rook
    % if (complField[lastSelection[M]][lastSelection[N]][PICE] == "R") {
    %     if (lastSelection[M] == m || lastSelection[N] == n) {
    %         return true;
    %     } else {
    %         printInfoText("Rook can not move there.");
    %         return false;
    %     }
    % }
    % % Bishop
    % else if (complField[lastSelection[M]][lastSelection[N]][PICE] == "B") {
    %     if (Math.abs(m - lastSelection[M]) == Math.abs(n - lastSelection[N])) {
    %         return true;
    %     } else {
    %         printInfoText("Bishop can not move there.");
    %         return false;
    %     }
    % }
    % % Knight
    % else if (complField[lastSelection[M]][lastSelection[N]][PICE] == "N") {
    %     if (Math.abs(m - lastSelection[M]) == Math.abs(n - lastSelection[N])) {
    %         return true;
    %     } else {
    %         printInfoText("Knight can not move there.");
    %         return false;
    %     }
    % }
    % % King
    % else if (complField[lastSelection[M]][lastSelection[N]][PICE] == "K") {
    %     % Only move one in each direction
    %     % TODO unless there is an enemy king in the neighboorhood of that field
    %     % TODO allow for castling
    %     if (Math.abs(m - lastSelection[M]) <= 1 && Math.abs(n - lastSelection[N]) <= 1) {
    %         return true;
    %     } else {
    %         printInfoText("King can not move there.");
    %         return false;
    %     }
    % }
    % % Queen
    % else if (complField[lastSelection[M]][lastSelection[N]][PICE] == "Q") {
    %     if (Math.abs(m - lastSelection[M]) == Math.abs(n - lastSelection[N]) ||
    %         lastSelection[M] == m || lastSelection[N] == n
    %     ) {
    %         return true;
    %     } else {
    %         printInfoText("Queen can not move there.");
    %         return false;
    %     }
    % }
    % % Pawn
    % else if (complField[lastSelection[M]][lastSelection[N]][PICE] == "P") {
    %     var state = complField[lastSelection[M]][lastSelection[N]][STATE];
    %     var piceColor = complField[lastSelection[M]][lastSelection[N]][COLOR];
    %     var targetColor = complField[m][n][COLOR];

    %     % Math.sign is not available
    %     var sign = function(x) { return ((x > 0) - (x < 0)) || +x; }

    %     % If enemy has jump over field allow for en passant TODO
    %     if (
    %         % If unmoved allow for a movement of two spaces
    %         state == UNMOVED && lastSelection[M] + piceColor * 2 == m ||
    %         % If there is an enemy across allow that move (opposite color)
    %         % Since black and white have the values 1 and -1 this calculation works
    %         sign(targetColor) == sign(piceColor) * -1 &&
    %         Math.abs(n - lastSelection[N]) == 1 &&
    %         lastSelection[M] + piceColor == m ||
    %         % Else allow only moving one forward when field empty
    %         targetColor == NONE && lastSelection[M] + piceColor == m && lastSelection[N] == n
    %     ) {
    %         return true;
    %     } else {
    %         printInfoText("Pawn can not move there.");
    %         return false;
    %     }
    % }

    return true;
}

function highlightValidMoves(enable) {
    if (complField[lastSelection[M]][lastSelection[N]][PICE] == "R") {

        const dirs = [
            [-1, 0],
            [1, 0],
            [0, -1],
            [0, 1]
        ];

        for (var i = 0; i < dirs.length; i++) {
            for (var o = 1; o < Math.max(FIELD_WIDTH, FIELD_HEIGHT); o++) {
                var m = lastSelection[M] + o * dirs[i][M];
                var n = lastSelection[N] + o * dirs[i][N];

                if (m < 0 || n < 0 || m >= FIELD_HEIGHT || n >= FIELD_WIDTH ||
                    complField[m][n][PICE] != EMPTY
                ) {
                    break;
                }
                highlight(m, n, POSS_MOVE_COLOR, enable);
            }
        }
    }
}

%%%%%%%%%%%%%%%%%%%%%
% Draw and coloring %
%%%%%%%%%%%%%%%%%%%%%
/**
 * Draws the complete field.
 */
function drawAll() {
    for (var m = 0; m < FIELD_HEIGHT; m++) {
        for (var n = 0; n < FIELD_WIDTH; n++) {
            draw(m, n);
        }
    }
}

/**
 * Draw the field at the coordinates m, n.
 *
 * @param {Number} m The m coordinate
 * @param {Number} n The n coordinate
 */
function draw(m, n) {
    % Retrieve the field data
    var cell = this.getField("cell" + m + "-" + n);
    cell.delay = true;

    var val = complField[m][n][PICE];
    cell.value = val;

    if (complField[m][n][COLOR] == WHITE) {
        cell.textColor = color.green;
    } else if (complField[m][n][COLOR] == BLACK) {
        cell.textColor = color.red;
    }

    if ((m + n) \% 2 == 0) {
        cell.borderColor = COLORS[WHITE + 1];
        cell.fillColor = COLORS[WHITE + 1];
    } else {
        cell.borderColor = COLORS[BLACK];
        cell.fillColor = COLORS[BLACK];
    }

    cell.delay = false;
}

function highlight(m, n, color, enable) {
    var cell = this.getField("cell" + m + "-" + n);
    cell.delay = true;

    if (enable) {
        cell.borderColor = color;
    } else {
        cell.borderColor = cell.fillColor;
    }
    cell.delay = false;
}

/**
 * Print information about the winner and the gamestate.
 */
function printInfoText(text) {
    var field = this.getField("info");
    field.delay = true;
    field.value = text;
    field.delay = false;
}

\end{insDLJS}

\OpenAction{/S /JavaScript /JS (initialise();)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dokument
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

    \begin{Form}

        % Header
        \begin{multicols}{2}
            % Title
            \section*{Chess}
        \columnbreak
            % Tooltip object
            \begin{flushright}%
                \PushButton[name=tooltipbtn, bordercolor=white]{%
                    \begin{tcolorbox}[width=20pt, height=20pt, left=3pt, top=0pt]
                        \centering?\strut{}
                    \end{tcolorbox}%
                }
            \end{flushright}%
        \end{multicols}

        % Calculate the max width and height of a block
        \FPeval{\resultW}{(\fieldWidth * 4 + 3)}
        \def\blocksizeW{\dimexpr (\linewidth-\resultW pt)/\fieldWidth \relax}

        \FPeval{\resultH}{(\fieldHeight * 4 + 3)}
        \def\blocksizeH{\dimexpr (500 pt -\resultH pt)/\fieldHeight \relax}

        % Define the blocksize via the smaller amount
        \ifnum\blocksizeW<\blocksizeH
            \def\blocksize{\blocksizeW}
        \else
            \def\blocksize{\blocksizeH}
        \fi

        % The gamefield
        \begin{tcolorbox}
            \begin{flushright}
                \xintFor* #1 in {\xintSeq{0}{\fieldHeight-1}} \do {%
                    \xintFor* #2 in {\xintSeq{0}{\fieldWidth-1}} \do {%
                        \TextField[%
                            width=\blocksize, height=\blocksize,%
                            bordercolor=white, name=cell#1-#2, readonly=true]{}\hspace{3pt}%
                    }\vspace{3pt}
                    \newline%
                }%
            \end{flushright}%
        \end{tcolorbox}

        % Game related buttons
        \begin{center}%
            \begin{tabularx}{\textwidth}{@{} *{2}{X} @{}}%
                \PushButton[name=restart, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        Restart
                        \strut
                    \end{tcolorbox}
                } &%
                \begin{tcolorbox}
                    \TextField[name=info, width=\linewidth, readonly=true]{}
                \end{tcolorbox}
            \end{tabularx}
        \end{center}

        \TextField[bordercolor=white, name=tooltiptxt, readonly=true]{}

    \end{Form}

\end{document}
