\documentclass[12pt, a4paper]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[margin=0.5in]{geometry}

\usepackage[pdftex]{hyperref}
\usepackage{multicol}

\usepackage{xinttools}
\usepackage[nomessages]{fp}
\usepackage{tabularx}
\usepackage{tcolorbox}

\setlength{\parindent}{0pt}

\usepackage[pdftex]{insdljs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO needs to be atleast 4
% Can be changed but impacts the performance
\def\fieldWidth{10}
\def\fieldHeight{16}
% Higher means slower
\def\GAMESPEED{5}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Javascript
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{insDLJS}[]{JSDateiname}{irgendeinTitel}

const GAME_DESC = "Tetris is a puzzle game where you get stones of a specific shape.\
These must be placed in such a manner that they build a complete line.\
A line will be removed to make space for more stones. With increasing amount\
of removed lines the gamespeed will increase. When the top of the field\
is reached the game is over.";

% Outside variables
const FIELD_WIDTH = AFMakeNumber(\fieldWidth);
const HALF_FIELD_WIDTH = Math.floor(FIELD_WIDTH / 2.0);
const FIELD_HEIGHT = AFMakeNumber(\fieldHeight);

% Constants
const EMPTY = 0;

% Globals
% Animation interval variable
var run;
% The game field
var complField = new Array();

var focus = true;
var loopTimer = 0;
var speed = AFMakeNumber(\GAMESPEED);
var lineCount = 0;

var stone = new Array();
var shouldEmitStone = true;
const STONES = new Array(
    % Bar
    new Array(
        new Array(HALF_FIELD_WIDTH - 2, 0),
        new Array(HALF_FIELD_WIDTH - 1, 0),
        new Array(HALF_FIELD_WIDTH, 0),
        new Array(HALF_FIELD_WIDTH + 1, 0)
    ),
    % Cube
    new Array(
        new Array(HALF_FIELD_WIDTH - 1, 0),
        new Array(HALF_FIELD_WIDTH - 1, 1),
        new Array(HALF_FIELD_WIDTH, 0),
        new Array(HALF_FIELD_WIDTH, 1)
    ),
    % T
    new Array(
        new Array(HALF_FIELD_WIDTH - 1, 0),
        new Array(HALF_FIELD_WIDTH, 0),
        new Array(HALF_FIELD_WIDTH, 1),
        new Array(HALF_FIELD_WIDTH + 1, 0)
    ),
    % Z
    new Array(
        new Array(HALF_FIELD_WIDTH - 1, 0),
        new Array(HALF_FIELD_WIDTH, 0),
        new Array(HALF_FIELD_WIDTH, 1),
        new Array(HALF_FIELD_WIDTH + 1, 1)
    ),
    % L
    new Array(
        new Array(HALF_FIELD_WIDTH - 1, 0),
        new Array(HALF_FIELD_WIDTH, 0),
        new Array(HALF_FIELD_WIDTH + 1, 0),
        new Array(HALF_FIELD_WIDTH + 1, 1)
    ),
    % J
    new Array(
        new Array(HALF_FIELD_WIDTH - 1, 1),
        new Array(HALF_FIELD_WIDTH - 1, 0),
        new Array(HALF_FIELD_WIDTH, 0),
        new Array(HALF_FIELD_WIDTH + 1, 0)
    ),
    % S
    new Array(
        new Array(HALF_FIELD_WIDTH - 1, 1),
        new Array(HALF_FIELD_WIDTH, 1),
        new Array(HALF_FIELD_WIDTH, 0),
        new Array(HALF_FIELD_WIDTH + 1, 0)
    )
);

% Color data
var stoneColor = color.black;
const COLORS = new Array(
    color.black,
    [ "RGB", 0.843, 0.078, 0.058 ],
    [ "RGB", 0.203, 0.603, 0.054 ],
    [ "RGB", 0.078, 0.305, 0.560 ],
    [ "RGB", 0.560, 0.078, 0.533 ]
);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initialisation and Restart %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/**
 * Initialise the default game state.
 */
function initialise() {
    for (var row = 0; row < FIELD_HEIGHT; row++) {
        var tmp = new Array();
        for (var column = 0; column < FIELD_WIDTH; column++) {
            tmp.push(EMPTY);
        }
        complField.push(tmp);
    }

    % Init the GUI
    initialiseButtons();

    % Start the animation interval
    run = app.setInterval("runAll()", 20);
}

/**
 * Initialise all buttons from the GUI.
 * For example add callbacks and set the correct colors.
 */
function initialiseButtons() {
    % Assign each button the coresponding function and disable the highlights
    this.getField("input1").setFocus();

    this.getField("left").setAction("MouseUp", "move('a');");
    this.getField("left").highlight="invert";

    this.getField("right").setAction("MouseUp", "move('d');");
    this.getField("right").highlight="invert";
    this.getField("down").setAction("MouseUp", "move('s');");
    this.getField("down").highlight="invert";
    this.getField("fulldown").setAction("MouseUp", "move(' ');");
    this.getField("fulldown").highlight="invert";

    this.getField("turnLeft").setAction("MouseUp", "move('q');");
    this.getField("turnLeft").highlight="invert";
    this.getField("turnRight").setAction("MouseUp", "move('e');");
    this.getField("turnRight").highlight="invert";

    this.getField("start").setAction("MouseUp", "restart();");
    this.getField("start").highlight="invert";

    % Tooltip setup
    this.getField("tooltipbtn").setAction("MouseDown", "tooltip(true);");
    this.getField("tooltipbtn").setAction("MouseUp", "tooltip(false);");
}

/**
 * Resets the gamefield to an empty field and restarts the game.
 */
function restart() {
    this.getField("points").value = 0;
    for (var row = 0; row < FIELD_HEIGHT; row++) {
        for (var column = 0; column < FIELD_WIDTH; column++) {
            complField[row][column] = EMPTY;
        }
    }

    loopTimer = 0;
    speed = AFMakeNumber(\GAMESPEED);
    lineCount = 0;

    shouldEmitStone = true;
}

/**
 * Enable or disable the tooltip.
 *
 * @param {Boolean} on Enable or disable tooltip.
 */
function tooltip(on) {
    if (on) {
        % Move the tooltip field to the center of the screen
        % and adjust the size so the text can be displayed
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = false;
        field.value = GAME_DESC;

        field.multiline = true;
        field.textSize = 16;
        % height 842, width 596
        % upper-left x, upper-left y, lower-right x and lower-right y
        field.rect = [128, 601, 468, 401];

        this.getField("tooltiptxt").setFocus();

        field.delay = false;
    } else {
        % Remove the field such that it is not visible
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = true;
        field.delay = false;
    }
}

%%%%%%%%
% Loop %
%%%%%%%%
/**
 * Main loop, responsible for processing the input, updating the field
 * and drawing.
 */
function runAll() {
    loopTimer++;
    processInput();
    updateField();
    if (!shouldEmitStone) {
        drawAll();
        % Stone needs to be removed so the gameover detection does not
        % misinterpret the current stone as gamelosing.
        % This is also needed for collision detection.
        removeStone();
    } else if (gameover()) {
        restart();
    }
}

%%%%%%%%%%%%%
% Gamelogic %
%%%%%%%%%%%%%
/**
 * Checks the top most line if there is a stone there.
 * @return {Boolean} If the game is over true else false.
 */
function gameover() {
    for (var column = 0; column < FIELD_WIDTH; column++) {
        if (complField[0][column] != 0) {
            return true;
        }
    }
    return false
}

/**
 * Emits a new random stone by adding it to the field.
 */
function emitStone() {
    % Random color
    stoneColor = Math.floor(Math.random() * COLORS.length) + 1;
    % Random shape
    var stoneIdx = Math.floor(Math.random() * STONES.length);
    for (var i = 0; i < STONES[stoneIdx].length; i++) {
        stone[i] = STONES[stoneIdx][i].slice();
    }
    % Set the stone
    for (var pice = 0; pice < stone.length; pice++) {
        var x = stone[pice][0];
        var y = stone[pice][1];
        complField[y][x] = stoneColor;
    }
    shouldEmitStone = false;
}

/**
 * Check if the stone collides with something below it or if it
 * reached the bottom of the field.
 * @return {Boolean} True when colliding else false
 */
function collidesOrHeight() {
    for (var pice = 0; pice < stone.length; pice++) {
        var x = stone[pice][0];
        var y = stone[pice][1];
        if (y + 1 >= FIELD_HEIGHT || complField[y + 1][x] != EMPTY) {
            return true;
        }
    }
    return false;
}

/**
 * Check if the stone collides with something on the left or if it
 * reached the left border of the field.
 * @return {Boolean} True when colliding else false
 */
function collidesOrLeft() {
    for (var pice = 0; pice < stone.length; pice++) {
        var x = stone[pice][0];
        var y = stone[pice][1];
        if (x - 1 < 0 || complField[y][x - 1] != EMPTY) {
            return true;
        }
    }
    return false;
}

/**
 * Check if the stone collides with something on the right or if it
 * reached the right border of the field.
 * @return {Boolean} True when colliding else false
 */
function collidesOrRight() {
    for (var pice = 0; pice < stone.length; pice++) {
        var x = stone[pice][0];
        var y = stone[pice][1];
        if (x + 1 >= FIELD_WIDTH || complField[y][x + 1] != EMPTY) {
            return true;
        }
    }
    return false;
}

/**
 * Removes all full lines of the field if there are any by
 * moving all lines above them down by one.
 * Add a new line at the top.
 */
function removeLines() {
    for (var y = FIELD_HEIGHT - 1; y >= 0; y--) {
        for (var x = 0; x < FIELD_WIDTH; x++) {
            % Line is not completly full
            if (complField[y][x] == EMPTY) {
                x = FIELD_WIDTH;
            }
            % Last field of line is reached and it is not empty
            else if (x == FIELD_WIDTH - 1 && complField[y][x] > EMPTY) {

                this.getField("points").value += 1000;
                lineCount++;
                % Adjust speed -> increase difficulty
                if (lineCount == 5 && speed > 1) {
                    lineCount = 0;
                    speed--;
                }
                % Remove the line by shifting all the lines above one down
                for (var move_y = y; move_y > 0; move_y--) {
                    complField[move_y] = complField[move_y - 1];
                }
                % Override the top line with a new one
                var tmp = new Array();
                for (var column = 0; column < FIELD_WIDTH; column++) {
                    tmp.push(EMPTY);
                }
                complField[0] = tmp;
                % Adjust y such that the shifted line is also tested
                y++;

            }
        }
    }
}

/**
 * Emits new stone if needed or moves the current one unless there is a
 * collision then the stone is added to the field as unmoveable.
 */
function updateField() {
    if (shouldEmitStone) {
        emitStone();
    }
    else {
        % Move if there is no collision and it is time otherwise
        % Add without movement
        if (!collidesOrHeight()) {
            if (loopTimer >= speed) {
                this.getField("points").value++;
                loopTimer = 0;
                for (var pice = 0; pice < stone.length; pice++) {
                    stone[pice][1]++;
                    var x = stone[pice][0];
                    var y = stone[pice][1];
                    complField[y][x] = stoneColor;
                }
            } else {
                for (var pice = 0; pice < stone.length; pice++) {
                    var x = stone[pice][0];
                    var y = stone[pice][1];
                    complField[y][x] = stoneColor;
                }
            }
        } else {
            % Add the stone to the field array
            for (var pice = 0; pice < stone.length; pice++) {
                var x = stone[pice][0];
                var y = stone[pice][1];
                complField[y][x] = stoneColor;
            }
            removeLines();
            shouldEmitStone = true;
        }
    }
}

/**
 * Removes the stone from the field.
 * Should be used temporary.
 */
function removeStone() {
    for (var pice = 0; pice < stone.length; pice++) {
        var x = stone[pice][0];
        var y = stone[pice][1];
        complField[y][x] = EMPTY;
    }
}

%%%%%%%%%%%%
% Movement %
%%%%%%%%%%%%
/**
 * Process input made by keys of the keyboard.
 * For this multiple input fields are needed for which the focus is shifted.
 * The input is then parsed into actual movement.
 */
function processInput() {
    var iField1 = this.getField("input1");
    var iField2 = this.getField("input2");
    var oField = this.getField("output1");

    iField1.delay = true;
    iField2.delay = true;
    oField.delay = true;

    % Get the input from the currently focused input element
    var movementString;
    if (focus) {
        iField1.setFocus();
        movementString = iField2.value;
        if (oField.value.length >= 10)
            oField.value = oField.value.slice(movementString.length);
        oField.value += movementString;
        iField2.value = "";
    } else {
        iField2.setFocus();
        movementString = iField1.value
        if (oField.value.length >= 10)
            oField.value = oField.value.slice(movementString.length);
        oField.value += movementString;
        iField1.value = "";
    }
    focus = !focus;

    % Process the input string
    for (var i = 0; i < movementString.length; i++) {
        move(movementString.charAt(i));
    }

    iField1.delay = false;
    iField2.delay = false;
    oField.delay = false;
}

/**
 * Move or rotate each part of the current stone in the direction given as
 * parameter unless it does collide.
 * @param {String} dir Expects a one char string that gives the direction.
 */
function move(dir) {
    switch(dir) {
        case "s": % One down
            if (!collidesOrHeight()) {
                for (pice = 0; pice < stone.length; pice++) {
                    stone[pice][1]++;
                }
            }
            break;
        case " ": % Full down
            while (!collidesOrHeight()) {
                for (pice = 0; pice < stone.length; pice++) {
                    stone[pice][1]++;
                }
            }
            break;
        case "a": % Left
            if (!collidesOrLeft()) {
                for (pice = 0; pice < stone.length; pice++) {
                    stone[pice][0]--;
                }
            }
            break;
        case "d": % Right
            if (!collidesOrRight()) {
                for (pice = 0; pice < stone.length; pice++) {
                    stone[pice][0]++;
                }
            }
            break;
        case "q": % Rotate
            var newPositions = new Array();
            for (var pice = 0; pice < stone.length; pice++) {
                var res = rotate(stone[0][0], stone[0][1], stone[pice][0], stone[pice][1], 90.0);
                if (collidesOrOOB(res[0], res[1]))
                    return;
                newPositions.push(res);
            }
            for (var pice = 0; pice < stone.length; pice++) {
                stone[pice][0] = newPositions[pice][0];
                stone[pice][1] = newPositions[pice][1];
            }
            break;
        case "e": % Rotate
            var newPositions = new Array();
            for (var pice = 0; pice < stone.length; pice++) {
                var res = rotate(stone[0][0], stone[0][1], stone[pice][0], stone[pice][1], -90.0);
                if (collidesOrOOB(res[0], res[1]))
                    return;
                newPositions.push(res);
            }
            for (var pice = 0; pice < stone.length; pice++) {
                stone[pice][0] = newPositions[pice][0];
                stone[pice][1] = newPositions[pice][1];
            }
            break;
    }
}

/**
 * Check the given position if it is out of bounds or collides.
 * @param {Number} x The x coordinate.
 * @param {Number} y The y coordinate.
 * @return {Boolean} True if collides else false
 */
function collidesOrOOB(x, y) {
    % Collides
    if (complField[y][x] > EMPTY) {
         return true;
    }
    % Out of bounds
    if (x < 0 || x >= FIELD_WIDTH || y < 0 || y >= FIELD_HEIGHT) {
        return true;
    }
    return false;
}

/**
 * Rotate the given coordinate around a given center.
 * https://stackoverflow.com/questions/17410809/how-to-calculate-rotation-in-2d-in-javascript
 * @param {Number} cx The center x coordinate.
 * @param {Number} cy The center y coordinate.
 * @param {Number} x The x coordinate.
 * @param {Number} y The y coordinate.
 * @param {Number} angle The angle at which to rotate.
 * @return {Array} The new position.
 */
function rotate(cx, cy, x, y, angle) {
    var radians = (Math.PI / 180) * angle;
    var cos = Math.cos(radians);
    var sin = Math.sin(radians);
    var nx = (cos * (x - cx)) + (sin * (y - cy)) + cx;
    var ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;
    return [Math.round(nx), Math.round(ny)];
}

%%%%%%%%%%%%%%%%%%%%%
% Draw and coloring %
%%%%%%%%%%%%%%%%%%%%%
/**
 * Draw all fields.
 */
function drawAll() {
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            draw(x, y);
        }
    }
}

/**
 * Since only one field is updated with each input,
 * only this field needs to be redrawn.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function draw(x, y) {
    var field = this.getField("pos" + x + "-" + y);
    field.delay = true;
    if (complField[y][x] > 0) {
        field.fillColor = COLORS[complField[y][x] - 1];
    } else {
        field.fillColor = color.white;
    }
    field.delay = false;
}

\end{insDLJS}

\OpenAction{/S /JavaScript /JS (initialise();)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dokument
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

    \begin{Form}

        % Header
        \begin{multicols}{2}
            % Title
            \section*{Tetris}
        \columnbreak
            % Tooltip object
            \begin{flushright}%
                \PushButton[name=tooltipbtn, bordercolor=, borderwidth=0]{%
                    \begin{tcolorbox}[width=20pt, height=20pt, left=3pt, top=0pt]
                        \centering?\strut{}
                    \end{tcolorbox}%
                }
            \end{flushright}%
        \end{multicols}

        % Dynamically adjust the cell width and height to the number of cells
        % Calculate the max width and height of a block
        \FPeval{\resultW}{(\fieldWidth * 3 - 2)} % chktex 8
        \def\blocksizeW{\dimexpr (\linewidth-\resultW pt)/\fieldWidth \relax}

        \FPeval{\resultH}{(\fieldHeight * 3 + 3)}
        \def\blocksizeH{\dimexpr (0.55\paperheight -\resultH pt)/\fieldHeight \relax}

        % The game board
        \begin{tcolorbox}
            % Define the cellsize via the smaller amount
            % Must be done here so the \linewidth has the correct value
            \ifdim\blocksizeW<\blocksizeH
                \def\blocksize{\blocksizeW}
            \else
                \def\blocksize{\blocksizeH}
            \fi

            \begin{center}
                \tiny
                \xintFor* #2 in {\xintSeq{0}{\fieldHeight-1}} \do {%
                    \xintFor* #1 in {\xintSeq{0}{\fieldWidth-1}} \do {%
                        \TextField[%
                            name=pos#1-#2, bordercolor=white,%
                            width=\blocksize, height=\blocksize, readonly%
                        ]{}%
                        \xintifForLast{}{\hspace{3pt}}%
                    }\vspace{3pt}\\[-1pt]%
                }
            \end{center}
        \end{tcolorbox}

        % Game related buttons
        \begin{center}%
            \begin{tabularx}{\textwidth}{@{} *{3}{X} @{}}%
                \PushButton[name=start, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        \Large start/restart\strut
                    \end{tcolorbox}
                } &
                \centering
                \TextField[name=points, width=0.25\linewidth, value=0,
                    bordercolor=, align=2, readonly]{Points:}&
                \PushButton[name=pause, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        \Large pause\strut
                    \end{tcolorbox}
                } \\
                \PushButton[name=turnLeft, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        \Large turnLeft\strut
                    \end{tcolorbox}
                } &
                    \centering
                    % bordercolor={0.650 .790 .94}
                    \TextField[name=output1, width=0.3\textwidth, height=1.5cm,
                        bordercolor=black, readonly]{}
                    %\begin{tcolorbox}
                    %\end{tcolorbox}
                &
                \PushButton[name=turnRight, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        \Large turnRight\strut
                    \end{tcolorbox}
                } \\
                \PushButton[name=left, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        \Large left\strut
                    \end{tcolorbox}
                } &
                \PushButton[name=down, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        \Large down\strut
                    \end{tcolorbox}
                } &
                \PushButton[name=right, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        \Large right\strut
                    \end{tcolorbox}
                } \\
                \multicolumn{3}{@{} l @{}}{%
                    \PushButton[name=fulldown, bordercolor=white]{
                        \begin{tcolorbox}
                            \centering
                            \Large fulldown\strut
                        \end{tcolorbox}
                    }
                }
            \end{tabularx}
        \end{center}

        \TextField[name=input1, width=2in, bordercolor={0.650 .790 .94}]{}
        \TextField[name=input2, width=2in, bordercolor={0.650 .790 .94}]{}

        \TextField[name=tooltiptxt, bordercolor=, backgroundcolor=gray, readonly, hidden]{}

    \end{Form}

\end{document}
