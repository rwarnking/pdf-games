\documentclass[12pt, a4paper, footexclude, headexclude]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[margin=0.5in]{geometry}

% \usepackage[utf8x]{inputenc}
% \usepackage[T1]{fontenc}
% \usepackage[ngerman]{babel}
% \usepackage{xcolor}
\usepackage[pdftex]{hyperref}
\usepackage{multicol}

\usepackage{xinttools}
% \usepackage[nomessages]{fp}
\usepackage{tabularx}
\usepackage{tcolorbox}

\setlength{\parindent}{0pt}

\usepackage[pdftex]{insdljs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Obacht: It is discuraged to use a field with size bigger than 15x15 since the pdf might get
% to slow to play
\def\fieldWidth{80}
\def\fieldHeight{30}
\def\obstacleCount{5}

% Max playercount is 5
\def\playerCount{5}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Javascript
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{insDLJS}[]{JSDateiname}{Gamename}

const GAME_DESC = "Text.\
Text.\
Text.\
Text.\
Text.";

% Outside variables
const FIELD_WIDTH = AFMakeNumber(\fieldWidth);
const FIELD_HEIGHT = AFMakeNumber(\fieldHeight);
const OBSTACLE_COUNT = AFMakeNumber(\obstacleCount);
const SCREEN_TEXT_WIDTH = 800;
const TEXT_SIZE = 40;
const ANIMATION_SPEED = 5;

% Constants
const LINE_OFFSET = 2;
const START_TOP_LINE = LINE_OFFSET;
const START_BOT_LINE = FIELD_HEIGHT - LINE_OFFSET - 1;

const X = 0;
const Y = 1;
const SYMB = 2;
const LEFT = 0;
const TOP = 1;
const RIGHT = 2;
const BOT = 3;
% document dims 842, 596
% upper-left x, upper-left y, lower-right x and lower-right y
const CANVAS_LTRB = [47.5, 770, 547.5, 241];
const CANVAS_HEIGHT = CANVAS_LTRB[TOP] - CANVAS_LTRB[BOT];
const CANVAS_WIDTH = CANVAS_LTRB[RIGHT] - CANVAS_LTRB[LEFT];
const CANVAS_CENTER_H = CANVAS_HEIGHT * 0.5 + CANVAS_LTRB[BOT];
const CANVAS_CENTER_W = CANVAS_WIDTH * 0.5 + CANVAS_LTRB[LEFT];
% Gravity stats
const GRAVITY = [0.0, -0.25];
var force = [0.0, 0.0];

const OBSTACLE_WIDTH = 20;
const PLAYER_WIDTH = 20;
const playerMass = 0.5;

% Globals
% The gameloop interval
var gameInterval;
var gameover = false;
% The game duration
var fieldCounter = 0;
% Indicator which input element is focused currently
var focus = true;
% Player attributes
var playerMomentum = [0.0, 0.0];
var playerPos = [CANVAS_CENTER_W * 0.5 + PLAYER_WIDTH, CANVAS_CENTER_H];
% Obstacle array
var obstacles = [];

% Color data
const COLORS = new Array(
    %[ "RGB", 0.843, 0.078, 0.058 ],
    %[ "RGB", 0.203, 0.603, 0.054 ],
    %[ "RGB", 0.078, 0.305, 0.560 ]
);

% Symbol array
const SYMBOLS = [
    0x2588, % block
    0x25CF, % circle
    0x260E, % telefon
    0x261E, % hand white
    0x261B, % hand black
    0x263B, % smilie
    0x266B, % note
    0x2702, % scissors
    0x2712, % pencil
    0x2706, % telefon2
    0x2707, % video
    0x2708, % plane
    0x2709, % mail
    0x2756, % diamond
    0x271F, % cross
    0x2717,
    0x274D,
    0x2730,
    0x2752,
    0x271C
];

%%%%%%%%%%
% Helper %
%%%%%%%%%%
/**
 * Returns a random float between the param min and the param max.
 * @param {Number} min The lowerbound
 * @param {Number} max The upperbound
 */
function getRandomFloat(min, max) {
    return min + Math.random() * (max - min);
}

/**
 * Returns a random number between 0 and the param.
 * @param {Number} max The upperbound
 */
function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initialisation and Restart %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/**
 * Initialise the default game state.
 */
function initialise() {
    % Init the GUI
    initialiseButtons();

    % Player rendering
    drawPlayer();

    % Draw continuously
    gameInterval = app.setInterval("gameLoop()", ANIMATION_SPEED);
    printInfoText("Initialised game!");
}

/**
 * Initialise all buttons from the GUI.
 * For example add callbacks and set the correct colors.
 */
function initialiseButtons() {
    % Disables the rectangle around a button after the click
    app.focusRect = false;

    this.getField("input1").setFocus();

    % Adjust text size and font
    var cell;
    for (var m = 0; m < FIELD_HEIGHT; m++) {
        cell = this.getField("line" + m);
        cell.textSize = SCREEN_TEXT_WIDTH / FIELD_WIDTH;
        cell.textFont = font.Cour;
    }

    % Init player
    var field = this.getField("player");
    field.value = String.fromCharCode(0x261B);
    field.textSize = TEXT_SIZE;
    field.alignment = "center";
    field.hidden = false;

    % Init obstacles
    for (var i = 0; i < OBSTACLE_COUNT; i++) {
        obstacles.push([-1, -1, "#"]);
        field = this.getField("obstacle" + i);
        field.textSize = TEXT_SIZE;
        field.alignment = "center";
    }

    % Assign each button the coresponding function and disable the highlights
    this.getField("restart").setAction("MouseUp", "restart();");

    % Info field setup
    this.getField("info").fillColor = color.transparent;
    this.getField("info").borderColor = color.transparent;

    % Tooltip setup
    this.getField("tooltipbtn").setAction("MouseDown", "tooltip(true);");
    this.getField("tooltipbtn").setAction("MouseUp", "tooltip(false);");
}

/**
 * Restart the game and clear everything
 */
function restart() {
    if (fieldCounter < FIELD_WIDTH) {
        return;
    }
    if (!gameover) {
        % In case the user restarted without gameover
        app.clearInterval(gameInterval);
    }
    gameover = false;
    fieldCounter = 0;

    % Reset canvas
    for (var m = 0; m < FIELD_HEIGHT; m++) {
        setField("line" + m,  "");
    }

    % Reset player
    playerMomentum = [0.0, 0.0];
    playerPos = [CANVAS_CENTER_W * 0.5 + PLAYER_WIDTH, CANVAS_CENTER_H];
    drawPlayer();

    % Reset obstacles
    for (var i = 0; i < OBSTACLE_COUNT; i++) {
        obstacles[i] = [-1, -1, "#"];
        % Reset highlight
        markObstacle(i, false);
    }
    % Draw the obstacles
    drawObstacles();

    % Draw continuously
    gameInterval = app.setInterval("gameLoop()", ANIMATION_SPEED);
    printInfoText("Restarted game!");
}

/**
 * Enable or disable the tooltip
 *
 * @param {Boolean} on Enable or disable tooltip
 */
function tooltip(on) {
    if (on) {
        % Move the tooltip field to the center of the screen
        % and adjust the size so the text can be displayed
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = false;
        field.value = GAME_DESC;

        field.multiline = true;
        field.textSize = 16;
        field.fillColor = color.gray;
        % height 842, width 596
        % upper-left x, upper-left y, lower-right x and lower-right y
        field.rect = [128, 601, 468, 401];

        field.delay = false;
    } else {
        % Remove the field such that it is not visible
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = true;
        field.value = "";

        field.multiline = false;
        field.fillColor = color.gray;
        field.rect = [0, 0, 0, 0];

        field.delay = false;
    }
}

%%%%%%%%%%%%%
% Gamelogic %
%%%%%%%%%%%%%
function gameLoop() {
    if (gameover) {
        app.clearInterval(gameInterval);
        printInfoText("Game over");
        return;
    }


    if (fieldCounter < FIELD_WIDTH) {
        printInfoText("Wait for the game to finish generating.");
    } else {
        printInfoText("You have currently " + (fieldCounter - FIELD_WIDTH) + " points.");
    }

    % Player movement
    if (fieldCounter >= FIELD_WIDTH) {
        processInput();
        applyGravityToPlayer();
    }

    % Check for collision and gameover
    var res = testCollisions();
    if (res != -1) {
        gameover = true;
        % Mark collided obstacle
        markObstacle(res, true);
        return;
    }

    % Draw the field
    drawField();

    if (fieldCounter >= FIELD_WIDTH) {
        % Refresh obstacles
        refreshObstacles();
        % Draw the obstacles
        drawObstacles();
    }

    % Player rendering
    drawPlayer();
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Obstacles and collision %
%%%%%%%%%%%%%%%%%%%%%%%%%%%
function refreshObstacles() {
    % Calculate units per line
    const perLine = CANVAS_HEIGHT / FIELD_HEIGHT;

    var spawn = getRandomFloat(0.0, 1.0) > 0.9;
    for (var i = 0; i < OBSTACLE_COUNT; i++) {
        if (obstacles[i][X] < CANVAS_LTRB[LEFT] && spawn) {
            var x = CANVAS_LTRB[RIGHT] + OBSTACLE_WIDTH;
            % Get current lines
            var curTop = getLine(fieldCounter, START_TOP_LINE);
            var curBot = getLine(fieldCounter, START_BOT_LINE);
            % Get bounds in units while keeping the lines in mind
            var uBound = CANVAS_LTRB[TOP] - curTop * perLine - OBSTACLE_WIDTH;
            var lBound = CANVAS_LTRB[BOT] + (FIELD_HEIGHT - curBot) * perLine + OBSTACLE_WIDTH;
            var y = getRandomFloat(lBound, uBound);

            var symb = String.fromCharCode(SYMBOLS[getRandomInt(SYMBOLS.length)]);
            obstacles[i] = [x, y, symb];
            spawn = false;
        } else {
            const OBSTACLE_MOVE_SPEED = 6;
            obstacles[i][X] -= OBSTACLE_MOVE_SPEED;
        }
    }
}

function testCollisions() {
    const pLeft = playerPos[X] - PLAYER_WIDTH;
    const pTop = playerPos[Y] + PLAYER_WIDTH;
    const pRight = playerPos[X] + PLAYER_WIDTH;
    const pBot = playerPos[Y] - PLAYER_WIDTH;

    % For all obstacles run a intersection test
    for (var i = 0; i < OBSTACLE_COUNT; i++) {
        var bLeft = obstacles[i][X] - PLAYER_WIDTH;
        var bTop = obstacles[i][Y] + PLAYER_WIDTH;
        var bRight = obstacles[i][X] + PLAYER_WIDTH;
        var bBot = obstacles[i][Y] - PLAYER_WIDTH;

        if (pLeft < bRight && pRight > bLeft &&
            pTop > bBot && pBot < bTop) {
            return i;
        }
    }

    return -1;
}

%%%%%%%%%%%%%%%%%%%%%%
% Input and movement %
%%%%%%%%%%%%%%%%%%%%%%
/**
 * Process input made by keys of the keyboard.
 * For this multiple input fields are needed for which the focus is shifted.
 * The input is then parsed into actual movement.
 */
function processInput() {
    var iField1 = this.getField("input1");
    var iField2 = this.getField("input2");

    % Get the input from the currently focused input element
    var movementString;
    if (focus) {
        iField1.setFocus();
        movementString = iField2.value;
        iField2.value = "";
    } else {
        iField2.setFocus();
        movementString = iField1.value
        iField1.value = "";
    }
    focus = !focus;

    % Process the input string
    if (movementString.length > 0) {
        var char = movementString.charAt(0);
        if (char == "w" || char == " ") {
            force[Y] = 2.0;
        }
    } else {
        force[Y] = 0.0;
    }
}

/**
 * Alters the position of the given particlce by using gravity.
 * The floor can be used to achieve a jumping motion.
 * Very similar the implementation found here:
 * https://gamedev.stackexchange.com/questions/10277/equation-for-bouncing-graph
 * @param {Number} p The particle index.
 * @param {Number} floor The y position at which the floor should be.
 */
function applyGravityToPlayer() {
    const g = GRAVITY;
    const f = force;
    const m = playerMass;
    var mom = playerMomentum;

    % Momentum += gravity + force
    mom = [mom[X] + g[X] + f[X], mom[Y] + g[Y] + f[Y]];
    % Velocity = momentum / mass
    var v = [mom[X] / m, mom[Y] / m];
    % Position += velocity
    var newPos = [playerPos[X] + v[X], playerPos[Y] + v[Y]];

    playerMomentum = mom;
    playerPos = newPos;
}

%%%%%%%%%%%%%%%%%%%%%
% Draw and coloring %
%%%%%%%%%%%%%%%%%%%%%
function getLine(xPos, baseline) {
    % xPos to radians (4x)
    const period = 1;
    var rad = (xPos / FIELD_WIDTH) * Math.PI * 2.0 * period;
    return Math.round(Math.sin(rad) * LINE_OFFSET + baseline);
}

/**
 * TODO
 * Shows next frame for the canvas, by adding the next symbol at the right and
 * shifting all lines one to the left.
 * If the game is over the animation interval is cleared.
 */
function drawField() {
    var tL = getLine(fieldCounter, START_TOP_LINE);
    var bL = getLine(fieldCounter, START_BOT_LINE);

    % Shift all lines
    for (var m = 0; m < FIELD_HEIGHT; m++) {
        var symb = " ";
        if (m == tL || m == bL) {
            symb = "*";
        }

        addToField("line" + m,  symb);

        if (fieldCounter >= FIELD_WIDTH) {
            shiftFieldLeft("line" + m);
        }
    }
    fieldCounter++;
}

function drawPlayer() {
    var field = this.getField("player");
    field.delay = true;

    % upper-left x, upper-left y, lower-right x and lower-right y
    field.rect = [
        playerPos[X] - PLAYER_WIDTH,
        playerPos[Y] + PLAYER_WIDTH,
        playerPos[X] + PLAYER_WIDTH,
        playerPos[Y] - PLAYER_WIDTH
    ];

    field.delay = false;
}

function drawObstacles() {
    for (var i = 0; i < OBSTACLE_COUNT; i++) {
        var field = this.getField("obstacle" + i);
        field.delay = true;
        field.value = obstacles[i][SYMB];

        % upper-left x, upper-left y, lower-right x and lower-right y
        field.rect = [
            Math.min(
                Math.max(obstacles[i][X] - PLAYER_WIDTH, CANVAS_LTRB[LEFT]),
                CANVAS_LTRB[RIGHT]
            ),
            obstacles[i][Y] + PLAYER_WIDTH,
            Math.min(
                Math.max(obstacles[i][X] + PLAYER_WIDTH, CANVAS_LTRB[LEFT]),
                CANVAS_LTRB[RIGHT]
            ),
            obstacles[i][Y] - PLAYER_WIDTH
        ];

        field.delay = false;
    }
}

function markObstacle(obs, enable) {
    var field = this.getField("obstacle" + obs);
    field.delay = true;
    if (enable) {
        field.borderColor = color.blue;
    } else {
        field.borderColor = color.transparent;
    }
    field.delay = false;
}

%%%%%%%%%%%%%%%%%%%%%%
% Modify cell values %
%%%%%%%%%%%%%%%%%%%%%%
/**
 * Shift the value of the given field.
 *
 * @param {Number} id The id of the field.
 */
function shiftFieldLeft(id) {
    var cell = this.getField(id);
    cell.delay = true;
    cell.value = cell.value.substring(1);
    cell.delay = false;
}

/**
 * Set string of the given field.
 *
 * @param {Number} id The id of the field.
 * @param {String} value The value to set.
 */
function setField(id, value) {
    var cell = this.getField(id);
    cell.delay = true;
    cell.value = value;
    cell.delay = false;
}

/**
 * Add string to the given field.
 *
 * @param {Number} id The id of the field.
 * @param {String} value The value to add.
 */
function addToField(id, value) {
    var cell = this.getField(id);
    cell.delay = true;
    cell.value += value;
    cell.delay = false;
}

/**
 * Print information about the winner and the gamestate.
 */
function printInfoText(text) {
    var field = this.getField("info");
    field.delay = true;
    field.value = text;
    field.delay = false;
}

\end{insDLJS}

\OpenAction{/S /JavaScript /JS (initialise();)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dokument
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

    \begin{Form}

        % Header
        \begin{multicols}{2}
            % Title
            \section*{Gamename}
        \columnbreak
            % Tooltip object
            \begin{flushright}%
                \PushButton[name=tooltipbtn, bordercolor=white]{%
                    \begin{tcolorbox}[width=20pt, height=20pt, left=3pt, top=0pt]
                        \centering?\strut{}
                    \end{tcolorbox}%
                }
            \end{flushright}%
        \end{multicols}

        % Calculate the max width and height of a block
        \def\blocksizeH{\dimexpr (500 pt)/\fieldHeight \relax}
        \def\blocksizeW{\dimexpr (500 pt) \relax}

        \begin{center}
            \xintFor* #1 in {\xintSeq{0}{\fieldHeight-1}} \do {%
                \TextField[%
                    width=\blocksizeW, height=\blocksizeH,%
                    bordercolor=, name=line#1, readonly=true%
                ]{}%
                \\[0pt]%
            }%
        \end{center}

        %%%%%%%%%%%%%%%%%%%%%%%
        % Commandredifinition %
        % https://www.dickimaw-books.com/latex/admin/html/eforms.shtml
        %%%%%%%%%%%%%%%%%%%%%%%
        % \def\DefaultHeightofText{14pt}
        % \renewcommand*{\LayoutTextField}[2]{%
        %     \parbox[c][\DefaultHeightofText]{0.5\linewidth}{#1#2}%
        % }

        % \renewcommand*{\LayoutCheckField}[2]{#1 #2}
        % \renewcommand*{\DefaultWidthofCheckBox}{2ex}
        % \renewcommand*{\DefaultHeightofCheckBox}{2ex}
        % \renewcommand*{\LayoutCheckField}[2]{%
        %     \parbox[c][\DefaultHeightofCheckBox]{0.12\linewidth}{#1}\enspace%
        %     \parbox[c][\DefaultHeightofCheckBox]{\DefaultWidthofCheckBox}{#2}%
        % }

        % \renewcommand*{\DefaultWidthofChoiceMenu}{2.5ex}
        % \renewcommand*{\DefaultHeightofChoiceMenu}{2.04ex}

        %%%%%%%%%%%%%%%%
        % GUI elements %
        %%%%%%%%%%%%%%%%
        \begin{center}
            % Game related buttons
            \begin{tabularx}{\textwidth}{@{} *{2}{X} @{}}%
                \PushButton[name=restart, bordercolor=white, borderwidth=0]{
                    \begin{tcolorbox}
                        \centering
                        Restart game\strut
                    \end{tcolorbox}
                } &
                \begin{tcolorbox}
                    \TextField[name=info, width=\linewidth, readonly=true]{}
                \end{tcolorbox}
            \end{tabularx}
        \end{center}

        \TextField[name=input1, width=2in, bordercolor={0.650 .790 .94}]{}
        \TextField[name=input2, width=2in, bordercolor={0.650 .790 .94}]{}

        \TextField[name=player, width=1cm, height=1cm,
            bordercolor=, backgroundcolor=, readonly, hidden
        ]{}

        \xintFor* #1 in {\xintSeq{0}{\obstacleCount-1}} \do {%
            \TextField[name=obstacle#1, width=1cm, height=1cm,%
                bordercolor=, backgroundcolor=, readonly=true%
            ]{}%
        }%

        \TextField[name=tooltiptxt, bordercolor=, readonly=true, hidden]{}

    \end{Form}
\end{document}
