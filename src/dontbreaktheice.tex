\documentclass[12pt, a4paper]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[margin=0.5in]{geometry}

\usepackage[pdftex]{hyperref}
\usepackage{multicol}

\usepackage{xinttools}
\usepackage[nomessages]{fp}
\usepackage{tabularx}
\usepackage{tcolorbox}

\setlength{\parindent}{0pt}

\usepackage[pdftex]{insdljs}

\graphicspath{{images/}{src/images/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Values can be changed
\def\boardWidth{10}
\def\boardHeight{12}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Javascript
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{insDLJS}[]{JSDateiname}{dbti}

const GAME_DESC = "The goal of this game is to get from the bottom of the board to the top,\
while only using specified cells. These cells are shown once in the beginning (red).\
Therefore the player needs to remember the path and click the right cells in\
the right order. If the user miss steps the game is lost";

% Outside variables
const BOARD_WIDTH = AFMakeNumber(\boardWidth);
const BOARD_HEIGHT = AFMakeNumber(\boardHeight);

% Constants
% For the path generation
const EMPTY = 0;
const REACHABLE = 1;
const FORBIDDEN = -1;
const IS_PATH = -2;
% For the visualisation
const HIDDEN = 0;
const R_REVEAL = 1;
const W_REVEAL = -1;

% Globals
% Animation interval variable
var run;
% The game board array
var complBoard = new Array();
var freePath = new Array();
% Lock if the game has ended
var gameover = false;
% Indicater which piece was last animated
var drawPiece = 0;
% Needed for so one cant play before the animation is finished
var play = false;
% Which board was found last
var currentBoard = -1;

% Color data
const COLORS = new Array(
    color.black,
    [ "RGB", 0.843, 0.078, 0.058 ],
    [ "RGB", 0.203, 0.603, 0.054 ],
    [ "RGB", 0.078, 0.305, 0.560 ],
    [ "RGB", 0.560, 0.078, 0.533 ]
);

%%%%%%%%%%
% Helper %
%%%%%%%%%%
/**
 * Returns a random number between 0 and the param.
 * @param {Number} max The upperbound
 */
function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initialisation and Restart %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/**
 * Initialise the default game state.
 */
function initialise() {
    for (var row = 0; row < BOARD_HEIGHT; row++) {
        var tmp = new Array();
        for (var column = 0; column < BOARD_WIDTH; column++) {
            tmp.push(EMPTY);
        }
        complBoard.push(tmp);
    }

    printInfoText("Select cells and find a way across.");

    % Init the GUI
    initialiseButtons();

    createPath();
}

/**
 * Initialise all buttons from the GUI.
 * For example add callbacks and set the correct colors.
 */
function initialiseButtons() {
    % Disables the rectangle around a button after the click
    app.focusRect = false;

    % Assign each button the coresponding function and disable the highlights
    this.getField("restart").setAction("MouseUp", "restart();");

    var funcName = "revealCell";
    for (var x = 0; x < BOARD_WIDTH; x++) {
        for (var y = 0; y < BOARD_HEIGHT; y++) {
            var callbackName = funcName + "(" + x.toString() + "," + y.toString() + ");";
            this.getField("pos" + x + "-" + y).setAction("MouseDown", callbackName);
        }
    }

    % Tooltip setup
    this.getField("tooltipbtn").setAction("MouseDown", "tooltip(true);");
    this.getField("tooltipbtn").setAction("MouseUp", "tooltip(false);");
}

/**
 * Restarts the game by clearing the board array and creating a new path.
 */
function restart() {
    % Prevent multiple restart processes at the same time
    if (!play) {
         return;
    }

    % Clear complBoard and redraw
    var cell;
    for (var x = 0; x < BOARD_WIDTH; x++) {
        for (var y = 0; y < BOARD_HEIGHT; y++) {
            complBoard[y][x] = EMPTY;

            cell = this.getField("pos" + x + "-" + y);
            cell.delay = true;
            cell.borderColor = color.white;
            cell.fillColor = color.white;
            cell.delay = false;
        }
    }

    % Reset board for other use
    for (var x = 0; x < BOARD_WIDTH; x++) {
        for (var y = 0; y < BOARD_HEIGHT; y++) {
            complBoard[y][x] = EMPTY;
        }
    }

    gameover = false;
    play = false;
    printInfoText("Select cells and find a way across.");
    createPath();
}

/**
 * Enable or disable the tooltip.
 *
 * @param {Boolean} on Enable or disable tooltip.
 */
function tooltip(on) {
    if (on) {
        % Move the tooltip field to the center of the screen
        % and adjust the size so the text can be displayed
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = false;
        field.value = GAME_DESC;

        field.multiline = true;
        field.textSize = 16;
        % height 842, width 596
        % upper-left x, upper-left y, lower-right x and lower-right y
        field.rect = [128, 601, 468, 401];

        this.getField("tooltiptxt").setFocus();

        field.delay = false;
    } else {
        % Remove the field such that it is not visible
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = true;
        field.delay = false;
    }
}

%%%%%%%%%%%%%%%%%%%
% Path generation %
%%%%%%%%%%%%%%%%%%%
/**
 * Creates the path from bottom to top.
 * This is done by marking the bot and top row as unreachable first.
 * Afterwards a list of all possible cells is created from which
 * a random one is selected until only one path is left.
 * After each draw it needs to be checked whether there is still a path,
 * if there is none the cell is added to the final path, since there is
 * none without this cell. When the list is empty only one path remains.
 *
 * Starts an animated draw after generating.
 */
function createPath() {
    freePath = new Array();

    var startX = getRandomInt(BOARD_WIDTH);
    var endX = getRandomInt(BOARD_WIDTH);

    % Mark bottom and top rowas unselectable
    for (var ix = 0; ix < BOARD_WIDTH; ix++) {
        complBoard[0][ix] = FORBIDDEN;
        complBoard[BOARD_HEIGHT - 1][ix] = FORBIDDEN;
    }

    % Create a list of all potential cells
    var cellList = [];
    for (var i = 0; i < BOARD_WIDTH; i++) {
        for (var j = 1; j < BOARD_HEIGHT - 1; j++) {
            cellList.push([i, j]);
        }
    }
    cellList.push([startX, BOARD_HEIGHT - 1]);

    % Loop as long as there are entrys in the list
    while (cellList.length !== 0) {
        % Get one random entry
        % Exclude the last entry since the algorithm does not
        % work otherwise, not sure why
        var rnd = getRandomInt(cellList.length - 1);
        var elem = cellList[rnd];

        % Remove and mark the cell
        cellList.splice(rnd, 1);
        complBoard[elem[1]][elem[0]] = FORBIDDEN;
        % If there is no path available after marking this cell,
        % the cell is needed for the path
        if (!doesPathExist([startX, BOARD_HEIGHT - 1], [endX, 0], complBoard)) {
            complBoard[elem[1]][elem[0]] = EMPTY;
        }
    }

    freePath = getPath([startX, BOARD_HEIGHT - 1], [endX, 0], complBoard);

    % Reset board for other use
    for (var x = 0; x < BOARD_WIDTH; x++) {
        for (var y = 0; y < BOARD_HEIGHT; y++) {
            complBoard[y][x] = EMPTY;
        }
    }

    currentBoard = -1;
    drawAll();

    % Animation interval
    run = app.setInterval("drawPath()", 300);
}

/**
 * Creates a path from the start position to the end position.
 * For this a list is generated to which all pathcells should be added.
 * Beginning with the start position the neighborhood is searched for
 * the next cell.
 * Works best if there is only one path.
 *
 * @param {Number} start The start 2D position.
 * @param {Number} end The end 2D position.
 * @param {Array} The board on which to search.
 * @return {Array} An array containing all positions of the path.
 */
function getPath(start, end, board) {
    var pathList = [start];
    % While the target is not reached search neighbourhood
    while (pathList[pathList.length - 1][0] !== end[0] ||
        pathList[pathList.length - 1][1] !== end[1]
    ) {
        var elem = pathList[pathList.length - 1];
    	board[elem[1]][elem[0]] = IS_PATH;

        % Push next piece
        var xpo = elem[0] + 1;
        var xmo = elem[0] - 1;
        var ypo = elem[1] + 1;
        var ymo = elem[1] - 1;

        var added = false;
       	if (ypo < BOARD_HEIGHT && board[ypo][elem[0]] == REACHABLE) {
        	pathList.push([elem[0], ypo]);
        	added = true;
        }
        if (ymo >= 0 && board[ymo][elem[0]] == REACHABLE) {
        	pathList.push([elem[0], ymo]);
        	added = true;
        }
        if (xpo < BOARD_WIDTH && board[elem[1]][xpo] == REACHABLE) {
        	pathList.push([xpo, elem[1]]);
        	added = true;
        }
        if (xmo >= 0 && board[elem[1]][xmo] == REACHABLE) {
        	pathList.push([xmo, elem[1]]);
        	added = true;
        }

        if (!added) {
            % Dead end reached, no path can be found!
            break;
        }
    }
    return pathList;
}

/**
 * Checks whether there is a path from the end to the start in the given board.
 * Starting with the end position a list is generated containing positions,
 * that are reachable and whose neighbors should be added to this list.
 * A position is removed after marking, resulting in an empty list when all
 * cells where either marked or could not be reached.
 * If the start cell is marked after the list is empty the cell can be
 * reached, otherwise it is not reachable.
 *
 * @param {Number} start The start 2D position.
 * @param {Number} end The end 2D position.
 * @param {Array} The board in which to search.
 * @return {Boolean} True if path exists false otherwise
 */
function doesPathExist(start, end, board) {
	% Cleanup: Ensure that there is no leftover data
	% that could come from earlier calls of this method
    for (var x = 0; x < BOARD_WIDTH; x++) {
        for (var y = 0; y < BOARD_HEIGHT; y++) {
            if (board[y][x] > EMPTY) {
                board[y][x] = EMPTY;
            }
        }
    }

    % Starting from the goal mark all cells to indicate
    % whether they can reach it
    var toMarkList = [end];
    board[end[1]][end[0]] = REACHABLE;
    board[start[1]][start[0]] = EMPTY;

    while (toMarkList.length !== 0) {
  	    var elem = toMarkList.pop();

        % Push neighbours if not marked
        var xpo = elem[0] + 1;
        var xmo = elem[0] - 1;
        var ypo = elem[1] + 1;
        var ymo = elem[1] - 1;

       	if (ypo < BOARD_HEIGHT && board[ypo][elem[0]] == EMPTY) {
        	toMarkList.push([elem[0], ypo]);
            % Mark the cell
            board[ypo][elem[0]] = REACHABLE;
        }
        if (ymo >= 0 && board[ymo][elem[0]] == EMPTY) {
        	toMarkList.push([elem[0], ymo]);
            % Mark the cell
            board[ymo][elem[0]] = REACHABLE;
        }
        if (xpo < BOARD_WIDTH && board[elem[1]][xpo] == EMPTY) {
        	toMarkList.push([xpo, elem[1]]);
            % Mark the cell
            board[elem[1]][xpo] = REACHABLE;
        }
        if (xmo >= 0 && board[elem[1]][xmo] == EMPTY) {
        	toMarkList.push([xmo, elem[1]]);
            % Mark the cell
            board[elem[1]][xmo] = REACHABLE;
        }
    }

	% Check the start cell if it is marked as reachable
    return board[start[1]][start[0]] == REACHABLE;
}

%%%%%%%%%%%%%
% Gamelogic %
%%%%%%%%%%%%%
/**
 * Reveal the selected cell and update the visuals accordingly.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function revealCell(x, y) {
    if (gameover || !play) {
        return;
    }

    % Is the cell a neighbour of the current or first line
    if (currentBoard == -1) {
        if (y != BOARD_HEIGHT -1) {
            return;
        }
    } else {
        var diffX = Math.abs(freePath[currentBoard][0] - x);
        var diffY = Math.abs(freePath[currentBoard][1] - y);
        if (diffX + diffY != 1) {
            return;
        }
    }

    % Test if the selected cell is on the path
    var hit = false;
    if (freePath[currentBoard + 1][0] == x && freePath[currentBoard + 1][1] == y) {
        complBoard[y][x] = R_REVEAL;
        hit = true;
        % Unmark the last neighbourhood
        if (currentBoard != -1) {
            markNeighbors(freePath[currentBoard][0], freePath[currentBoard][1], false);
        }
        % Move to next cell
        currentBoard++;
        if (currentBoard == freePath.length - 1) {
            gameover = true;
            printInfoText("Congratulations you found a way across!");
        }
        % Mark the neighboring cells that are accessible
        markNeighbors(x, y, true);
    }

    % If nothing was hit the game is over
    % Mark the miss accordingly
    if (!hit) {
        gameover = true;
        for (var idx = 0; idx < freePath.length; idx++) {
            complBoard[freePath[idx][1]][freePath[idx][0]] = 1;
        }
        complBoard[y][x] = -1;
        printInfoText("Sadly you died!");
    }

    draw(x, y);
}

%%%%%%%%%%%%%%%%%%%%%
% Draw and coloring %
%%%%%%%%%%%%%%%%%%%%%
/**
 * Draw all cells.
 */
function drawAll() {
    for (var x = 0; x < BOARD_WIDTH; x++) {
        for (var y = 0; y < BOARD_HEIGHT; y++) {
            draw(x, y);
        }
    }
}

/**
 * Since only one cell is updated with each input,
 * only this cell needs to be redrawn.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function draw(x, y) {
    var cell = this.getField("pos" + x + "-" + y);
    cell.delay = true;
    var value = complBoard[y][x];
    % If the cell was correctly revealed
    if (value > HIDDEN) {
        cell.fillColor = COLORS[1];
        cell.borderColor = COLORS[1];
    }
    % If the cell was wrongly revealed
    else if (value < HIDDEN) {
        cell.fillColor = COLORS[0];
        cell.borderColor = COLORS[0];
    }
    % Not revealed
    else {
        cell.fillColor = color.white;
        cell.borderColor = color.white;
    }
    cell.delay = false;
}

/**
 * Start an animated draw of the generated path.
 * After all pieces of the path where revealed once,
 * everything is cleared again.
 */
function drawPath() {
    % Test if animation has finished then reset
    if (drawPiece >= freePath.length) {
        drawPiece = 0;
        for (var idx = 0; idx < freePath.length; idx++) {
            complBoard[freePath[idx][1]][freePath[idx][0]] = HIDDEN;
            draw(freePath[idx][0], freePath[idx][1]);
        }
        play = true;
        app.clearInterval(run);
    } else {
        % Redraw and continue
        complBoard[freePath[drawPiece][1]][freePath[drawPiece][0]] = R_REVEAL;
        draw(freePath[drawPiece][0], freePath[drawPiece][1]);

        drawPiece++;
    }
}

/**
 * Highlight the neighboring cells of the given position.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function markNeighbors(x, y, mark) {
    % Define the neighbourhood
    var directions = [[-1, 0], [1, 0], [0, 1], [0, -1]]

    for (var idx = 0; idx < directions.length; idx++) {
        var newX = x + directions[idx][0];
        var newY = y + directions[idx][1];

        % Check for out of bounds
        if (newX < 0 || newX >= BOARD_WIDTH || newY < 0 || newY >= BOARD_HEIGHT) {
            continue;
        }

        var cell = this.getField("pos" + newX + "-" + newY);
        cell.delay = true;
        if (mark) {
            cell.borderColor = COLORS[2];
        } else {
            cell.borderColor = color.white;
        }
        cell.delay = false;
    }
}

/**
 * Print information about the winner and the gamestate.
 */
function printInfoText(text) {
    var field = this.getField("info");
    field.delay = true;
    field.value = text;
    field.delay = false;
}

\end{insDLJS}

\OpenAction{/S /JavaScript /JS (initialise();)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dokument
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

    \begin{Form}

        % Header
        \begin{multicols}{2}
            % Title
            \section*{Don't break the ice}
        \columnbreak
            % Tooltip object
            \begin{flushright}%
                \PushButton[name=tooltipbtn, bordercolor=, backgroundcolor=, borderwidth=0]{%
                    \begin{tcolorbox}[width=20pt, height=20pt, left=3pt, top=0pt]
                        \centering?\strut{}
                    \end{tcolorbox}%
                }
            \end{flushright}%
        \end{multicols}

        % Dynamically adjust the cell width and height to the number of cells
        % Calculate the max width and height of a cell
        \FPeval{\resultW}{\boardWidth * 3 - 2} % chktex 8
        \def\cellWidth{\dimexpr (\linewidth-\resultW pt)/\boardWidth \relax}

        \FPeval{\resultH}{\boardHeight * 3 + 3}
        \def\cellHeight{\dimexpr (500 pt -\resultH pt)/\boardHeight \relax}

        \begin{tcolorbox}
            % Define the cellsize via the smaller amount
            % Must be done here so the \linewidth has the correct value
            \ifdim\cellWidth<\cellHeight
                \def\cellsize{\cellWidth}
            \else
                \def\cellsize{\cellHeight}
            \fi
            %
            \begin{center}
                \tiny
                \includegraphics[width=0.25\textwidth]{end}\\[2pt]
                %
                \xintFor* #2 in {\xintSeq{0}{\boardHeight-1}} \do {%
                    \xintFor* #1 in {\xintSeq{0}{\boardWidth-1}} \do {%
                        \TextField[
                            name=pos#1-#2, width=\cellsize, height=\cellsize,%
                            bordercolor=white, readonly%
                        ]{}%
                        \xintifForLast{}{\hspace{3pt}}%
                    }\vspace{3pt}\\[-1pt]%
                }%
                \includegraphics[width=0.25\textwidth]{start}
            \end{center}%
        \end{tcolorbox}

        \begin{center}%
            \begin{tabularx}{\textwidth}{@{} *{2}{X} @{}}%
                \PushButton[name=restart, bordercolor=, backgroundcolor=, borderwidth=0]{
                    \begin{tcolorbox}
                        \centering
                        Restart game\strut
                    \end{tcolorbox}
                } &
                \begin{tcolorbox}
                    \TextField[name=info, width=\linewidth,
                        bordercolor=, backgroundcolor=, readonly]{}
                \end{tcolorbox}
            \end{tabularx}
        \end{center}

        \TextField[name=tooltiptxt, bordercolor=, backgroundcolor=gray, readonly, hidden]{}
    \end{Form}

\end{document}
