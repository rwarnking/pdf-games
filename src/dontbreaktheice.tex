\documentclass[12pt, a4paper]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[margin=0.5in]{geometry}

\usepackage[ngerman]{babel}
\usepackage{xcolor}
\usepackage[pdftex]{hyperref}
\usepackage{multicol}

\usepackage{xinttools}
\usepackage[nomessages]{fp}
\usepackage{tabularx}
\usepackage{tcolorbox}

\setlength{\parindent}{0pt}

\usepackage[pdftex]{insdljs}

\graphicspath{{images/}{src/images/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\fieldWidth{10}
\def\fieldHeight{12}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Javascript
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{insDLJS}[]{JSDateiname}{DBTI}

const GAME_DESC = "The goal of this game is to get from the bottom of the field to the top,\
while only using specified fields. These fields are shown once in the beginning (red).\
Therefore the player needs to remember the path and click the right fields in\
the right order. If the user misssteps the game is lost";

% Outside variables
const FIELD_WIDTH = AFMakeNumber(\fieldWidth);
const FIELD_HEIGHT = AFMakeNumber(\fieldHeight);

% Constants
% For the path generation
const EMPTY = 0;
const REACHABLE = 1;
const FORBIDDEN = -1;
const IS_PATH = -2;
% For the visualisation
const HIDDEN = 0;
const R_REVEAL = 1;
const W_REVEAL = -1;

% Globals
% Animation interval variable
var run;
% The game field array
var complField = new Array();
var freePath = new Array();
% Lock if the game has ended
var gameover = false;
% Indicater which piece was last animated
var drawPiece = 0;
% Needed for so one cant play before the animation is finished
var play = false;
% Which field was found last
var currentField = -1;

% Color data
const COLORS = new Array(
    color.black,
    [ "RGB", 0.843, 0.078, 0.058 ],
    [ "RGB", 0.203, 0.603, 0.054 ],
    [ "RGB", 0.078, 0.305, 0.560 ],
    [ "RGB", 0.560, 0.078, 0.533 ]
);

%%%%%%%%%%
% Helper %
%%%%%%%%%%
/**
 * Returns a random number between 0 and the param.
 * @param {Number} max The upperbound
 */
function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initialisation and Restart %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/**
 * Initialise the default game state.
 */
function initialise() {
    for (var row = 0; row < FIELD_HEIGHT; row++) {
        var tmp = new Array();
        for (var column = 0; column < FIELD_WIDTH; column++) {
            tmp.push(EMPTY);
        }
        complField.push(tmp);
    }

    this.getField("info").fillColor = color.transparent;
    this.getField("info").borderColor = color.transparent;

    printInfoText("Select fields and find a way across.");

    % Init the GUI
    initialiseButtons();

    createPath();
}

/**
 * Initialise all buttons from the GUI.
 * For example add callbacks and set the correct colors.
 */
function initialiseButtons() {
    % Assign each button the coresponding function and disable the highlights
    this.getField("restart").setAction("MouseUp", "restart();");
    this.getField("restart").highlight="none";

    var funcName = "revealField";
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            var callbackName = funcName + "(" + x.toString() + "," + y.toString() + ");";
            this.getField("pos" + x + "-" + y).setAction("MouseDown", callbackName);
        }
    }

    % Tooltip setup
    this.getField("tooltipbtn").setAction("MouseDown", "tooltip(true);");
    this.getField("tooltipbtn").setAction("MouseUp", "tooltip(false);");
}

/**
 * Restarts the game by clearing the field array and creating a new path.
 */
function restart() {
    % Prevent multiple restart processes at the same time
    if (!play) {
         return;
    }

    % Clear complField and redraw
    var field;
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            complField[y][x] = EMPTY;

            field = this.getField("pos" + x + "-" + y);
            field.delay = true;
            field.borderColor = color.white;
            field.fillColor = color.white;
            field.delay = false;
        }
    }

    % Reset field for other use
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            complField[y][x] = EMPTY;
        }
    }

    gameover = false;
    play = false;
    printInfoText("Select fields and find a way across.");
    createPath();
}

/**
 * Enable or disable the tooltip.
 *
 * @param {Boolean} on Enable or disable tooltip.
 */
function tooltip(on) {
    if (on) {
        % Move the tooltip field to the center of the screen
        % and adjust the size so the text can be displayed
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = false;
        field.value = GAME_DESC;

        field.multiline = true;
        field.textSize = 16;
        % height 842, width 596
        % upper-left x, upper-left y, lower-right x and lower-right y
        field.rect = [128, 601, 468, 401];

        this.getField("tooltiptxt").setFocus();

        field.delay = false;
    } else {
        % Remove the field such that it is not visible
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = true;
        field.delay = false;
    }
}

%%%%%%%%%%%%%%%%%%%
% Path generation %
%%%%%%%%%%%%%%%%%%%
/**
 * Creates the path from bottom to top.
 * This is done by marking the bot and top row as unreachable first.
 * Afterwards a list of all possible slots is created from which
 * a random one is selected until only one path is left.
 * After each draw it needs to be checked wether there is still a path,
 * if there is none the field is added to the final path, since there is
 * none without this field. When the list is empty only one path remains.
 *
 * Starts an animated draw after generating.
 */
function createPath() {
    freePath = new Array();

    var startX = getRandomInt(FIELD_WIDTH);
    var endX = getRandomInt(FIELD_WIDTH);

    % Mark bottom and top rowas unselectable
    for (var ix = 0; ix < FIELD_WIDTH; ix++) {
        complField[0][ix] = FORBIDDEN;
        complField[FIELD_HEIGHT - 1][ix] = FORBIDDEN;
    }

    % Create a list of all potential fields
    var fieldList = [];
    for (var i = 0; i < FIELD_WIDTH; i++) {
        for (var j = 1; j < FIELD_HEIGHT - 1; j++) {
            fieldList.push([i, j]);
        }
    }
    fieldList.push([startX, FIELD_HEIGHT - 1]);

    % Loop as long as there are entrys in the list
    while (fieldList.length !== 0) {
        % Get one random entry
        % Exclude the last entry since the algorithm does not
        % work otherwise, not sure why
        var rnd = getRandomInt(fieldList.length - 1);
        var elem = fieldList[rnd];

        % Remove and mark the field
        fieldList.splice(rnd, 1);
        complField[elem[1]][elem[0]] = FORBIDDEN;
        % If there is no path available after marking this field,
        % the field is needed for the path
        if (!doesPathExist([startX, FIELD_HEIGHT - 1], [endX, 0], complField)) {
            complField[elem[1]][elem[0]] = EMPTY;
        }
    }

    freePath = getPath([startX, FIELD_HEIGHT - 1], [endX, 0], complField);

    % Reset field for other use
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            complField[y][x] = EMPTY;
        }
    }

    currentField = -1;
    drawAll();

    % Animation interval
    run = app.setInterval("drawPath()", 300);
}

/**
 * Creates a path from the start position to the end position.
 * For this a list is generated to which all pathfields should be added.
 * Beginning with the start position the neighbourhood is searched for
 * the next field.
 * Works best if there is only one path.
 *
 * @param {Number} start The start 2D position.
 * @param {Number} end The end 2D position.
 * @param {Array} The field in which to search.
 * @return {Array} An array containing all positions of the path.
 */
function getPath(start, end, field) {
    var pathList = [start];
    % While the target is not reached search neighbourhood
    while (pathList[pathList.length - 1][0] !== end[0] ||
        pathList[pathList.length - 1][1] !== end[1]
    ) {
        var elem = pathList[pathList.length - 1];
    	field[elem[1]][elem[0]] = IS_PATH;

        % Push next piece
        var xpo = elem[0] + 1;
        var xmo = elem[0] - 1;
        var ypo = elem[1] + 1;
        var ymo = elem[1] - 1;

        var added = false;
       	if (ypo < FIELD_HEIGHT && field[ypo][elem[0]] == REACHABLE) {
        	pathList.push([elem[0], ypo]);
        	added = true;
        }
        if (ymo >= 0 && field[ymo][elem[0]] == REACHABLE) {
        	pathList.push([elem[0], ymo]);
        	added = true;
        }
        if (xpo < FIELD_WIDTH && field[elem[1]][xpo] == REACHABLE) {
        	pathList.push([xpo, elem[1]]);
        	added = true;
        }
        if (xmo >= 0 && field[elem[1]][xmo] == REACHABLE) {
        	pathList.push([xmo, elem[1]]);
        	added = true;
        }

        if (!added) {
            % Dead end reached, no path can be found!
            break;
        }
    }
    return pathList;
}

/**
 * Checks wether there is a path from the end to the start in the given field.
 * Starting with the end position a list is generated containing positions,
 * that are reachable and whose neighbours should be added to this list.
 * A position is removed after marking, resulting in an empty list when all
 * fields where either marked or could not be reached.
 * If the start field is marked after the list is empty the field can be
 * reached, otherwise it is not reachable.
 *
 * @param {Number} start The start 2D position.
 * @param {Number} end The end 2D position.
 * @param {Array} The field in which to search.
 * @return {Boolean} True if path exists false otherwise
 */
function doesPathExist(start, end, field) {
	% Cleanup: Ensure that there is no leftover data
	% that could come from earlier calls of this method
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            if (field[y][x] > EMPTY) {
                field[y][x] = EMPTY;
            }
        }
    }

    % Starting from the goal mark all fields to indicate
    % whether they can reach it
    var toMarkList = [end];
    field[end[1]][end[0]] = REACHABLE;
    field[start[1]][start[0]] = EMPTY;

    while (toMarkList.length !== 0) {
  	    var elem = toMarkList.pop();

        % Push neighbours if not marked
        var xpo = elem[0] + 1;
        var xmo = elem[0] - 1;
        var ypo = elem[1] + 1;
        var ymo = elem[1] - 1;

       	if (ypo < FIELD_HEIGHT && field[ypo][elem[0]] == EMPTY) {
        	toMarkList.push([elem[0], ypo]);
            % Mark the field
            field[ypo][elem[0]] = REACHABLE;
        }
        if (ymo >= 0 && field[ymo][elem[0]] == EMPTY) {
        	toMarkList.push([elem[0], ymo]);
            % Mark the field
            field[ymo][elem[0]] = REACHABLE;
        }
        if (xpo < FIELD_WIDTH && field[elem[1]][xpo] == EMPTY) {
        	toMarkList.push([xpo, elem[1]]);
            % Mark the field
            field[elem[1]][xpo] = REACHABLE;
        }
        if (xmo >= 0 && field[elem[1]][xmo] == EMPTY) {
        	toMarkList.push([xmo, elem[1]]);
            % Mark the field
            field[elem[1]][xmo] = REACHABLE;
        }
    }

	% Check the start field if it is marked as reachable
    return field[start[1]][start[0]] == REACHABLE;
}

%%%%%%%%%%%%%
% Gamelogic %
%%%%%%%%%%%%%
/**
 * Reveal the selected field and update the visuals accordingly.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function revealField(x, y) {
    if (gameover || !play) {
        return;
    }

    % Is field a neighbour of the current or first line
    if (currentField == -1) {
        if (y != FIELD_HEIGHT -1) {
            return;
        }
    } else {
        var diffX = Math.abs(freePath[currentField][0] - x);
        var diffY = Math.abs(freePath[currentField][1] - y);
        if (diffX + diffY != 1) {
            return;
        }
    }

    % Test if the selected field is on the path
    var hit = false;
    if (freePath[currentField + 1][0] == x && freePath[currentField + 1][1] == y) {
        complField[y][x] = R_REVEAL;
        hit = true;
        % Unmark the last neighbourhood
        if (currentField != -1) {
            markNeighbors(freePath[currentField][0], freePath[currentField][1], false);
        }
        % Move to next field
        currentField++;
        if (currentField == freePath.length - 1) {
            gameover = true;
            printInfoText("Congratulations you found a way across!");
        }
        % Mark the neighbouring fields that are accessible
        markNeighbors(x, y, true);
    }

    % If nothing was hit the game is over
    % Mark the miss accordingly
    if (!hit) {
        gameover = true;
        for (var idx = 0; idx < freePath.length; idx++) {
            complField[freePath[idx][1]][freePath[idx][0]] = 1;
        }
        complField[y][x] = -1;
        printInfoText("Sadly you died!");
    }

    draw(x, y);
}

%%%%%%%%%%%%%%%%%%%%%
% Draw and coloring %
%%%%%%%%%%%%%%%%%%%%%
/**
 * Draw all fields.
 */
function drawAll() {
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            draw(x, y);
        }
    }
}

/**
 * Since only one field is updated with each input,
 * only this field needs to be redrawn.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function draw(x, y) {
    var field = this.getField("pos" + x + "-" + y);
    field.delay = true;
    var value = complField[y][x];
    % If the field was correctly revealed
    if (value > HIDDEN) {
        field.fillColor = COLORS[1];
        field.borderColor = COLORS[1];
    }
    % If the field was wrongly revealed
    else if (value < HIDDEN) {
        field.fillColor = COLORS[0];
        field.borderColor = COLORS[0];
    }
    % Not revealed
    else {
        field.fillColor = color.white;
        field.borderColor = color.white;
    }
    field.delay = false;
}

/**
 * Start an animated draw of the generated path.
 * After all pieces of the path where revealed once,
 * everything is cleared again.
 */
function drawPath() {
    % Test if animation has finished then reset
    if (drawPiece >= freePath.length) {
        drawPiece = 0;
        for (var idx = 0; idx < freePath.length; idx++) {
            complField[freePath[idx][1]][freePath[idx][0]] = HIDDEN;
            draw(freePath[idx][0], freePath[idx][1]);
        }
        play = true;
        app.clearInterval(run);
    } else {
        % Redraw and continue
        complField[freePath[drawPiece][1]][freePath[drawPiece][0]] = R_REVEAL;
        draw(freePath[drawPiece][0], freePath[drawPiece][1]);

        drawPiece++;
    }
}

/**
 * Highlight the neighboring fields of the given position.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function markNeighbors(x, y, mark) {
    % Define the neighbourhood
    var directions = [[-1, 0], [1, 0], [0, 1], [0, -1]]

    for (var idx = 0; idx < directions.length; idx++) {
        var newX = x + directions[idx][0];
        var newY = y + directions[idx][1];

        % Check for out of bounds
        if (newX < 0 || newX >= FIELD_WIDTH || newY < 0 || newY >= FIELD_HEIGHT) {
            continue;
        }

        field = this.getField("pos" + newX + "-" + newY);
        field.delay = true;
        if (mark) {
            field.borderColor = COLORS[2];
        } else {
            field.borderColor = color.white;
        }
        field.delay = false;
    }
}

/**
 * Print information about the winner and the gamestate.
 */
function printInfoText(text) {
    var field = this.getField("info");
    field.delay = true;
    field.value = text;
    field.delay = false;
}

\end{insDLJS}

\OpenAction{/S /JavaScript /JS (initialise();)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dokument
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

    \begin{Form}

        % Header
        \begin{multicols}{2}
            % Title
            \section*{Don't break the ice}
        \columnbreak
            % Tooltip object
            \begin{flushright}%
                \PushButton[name=tooltipbtn, bordercolor=, borderwidth=0]{%
                    \begin{tcolorbox}[width=20pt, height=20pt, left=3pt, top=0pt]
                        \centering?\strut{}
                    \end{tcolorbox}%
                }
            \end{flushright}%
        \end{multicols}

        % Calculate the max width and height of a block
        \FPeval{\resultW}{(\fieldWidth * 4 + 3)}
        \def\blocksizeW{\dimexpr (\linewidth-\resultW pt)/\fieldWidth \relax}

        \FPeval{\resultH}{(\fieldHeight * 4 + 3)}
        \def\blocksizeH{\dimexpr (500 pt -\resultH pt)/\fieldHeight \relax}

        % Define the blocksize via the smaller amount
        \ifnum\blocksizeW<\blocksizeH
            \def\blocksize{\blocksizeW}
        \else
            \def\blocksize{\blocksizeH}
        \fi

        \begin{tcolorbox}
            \centering%
            \includegraphics[width=0.25\textwidth]{end}
            %
            \begin{flushright}
                \xintFor* #2 in {\xintSeq{0}{\fieldHeight-1}} \do {%
                    \xintFor* #1 in {\xintSeq{0}{\fieldWidth-1}} \do {%
                        \TextField[width=\blocksize, height=\blocksize,%
                            bordercolor=white, name=pos#1-#2, readonly=true%
                        ]{}\hspace{3pt}%
                    }\vspace{3pt}%
                    \newline%
                }%
            \end{flushright}%
            %
            \centering%
            \includegraphics[width=0.25\textwidth]{start}
            \TextField[name=tooltiptxt, bordercolor=, backgroundcolor=gray, readonly, hidden]{}
        \end{tcolorbox}

        \begin{center}%
            \begin{tabularx}{\textwidth}{@{} *{2}{X} @{}}%
                \PushButton[name=restart, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        Restart game\strut
                    \end{tcolorbox}
                } &
                \begin{tcolorbox}
                    \TextField[name=info, width=\linewidth, readonly=true]{}
                \end{tcolorbox}
            \end{tabularx}
        \end{center}

    \end{Form}

\end{document}
