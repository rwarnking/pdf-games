\documentclass[12pt, a4paper]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[margin=0.5in]{geometry}

\usepackage[pdftex]{hyperref}
\usepackage{multicol}

\usepackage{xinttools}
\usepackage[nomessages]{fp}
\usepackage{tabularx}
\usepackage{tcolorbox}

\setlength{\parindent}{0pt}

\usepackage[pdftex]{insdljs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Can be changed but 20-30 seem to be a good values
\def\canvasWidth{20}
\def\canvasHeight{\canvasWidth}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Javascript
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{insDLJS}[]{JSDateiname}{ascii-donut}

const GAME_DESC = "This application uses ASCII characters to visualize\
a rotating donut. The idea is to use the different symbols to simulate\
the different orientations and lighting states.";

% Outside variables
const CANVAS_WIDTH = AFMakeNumber(\canvasWidth);
const CANVAS_HEIGHT = AFMakeNumber(\canvasHeight);
const SCREEN_TEXT_SIZE = 350;

% Constants
const SCALE = 10;
const ANIMATION_SPEED = 300;

const CHAR_SET = ".,-~:;=!*#S@";

% Globals
% Animation interval variable
var animInterval;
% The display arrays
var output = new Array();
var zbuffer = new Array();

% Algorithm vars
var A = 0;
var B = 0;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initialisation and Restart %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/**
 * Initialise the default donut state.
 */
function initialise() {
    var cell;
    for (var m = 0; m < CANVAS_HEIGHT; m++) {
        for (var n = 0; n < CANVAS_WIDTH; n++) {
            cell = this.getField("cell" + m + "-" + n);
            cell.delay = true;
            cell.textColor = color.white
            cell.textSize = SCREEN_TEXT_SIZE / Math.max(CANVAS_HEIGHT, CANVAS_WIDTH);
            cell.delay = false;
        }
    }

    for (var m = 0; m < CANVAS_HEIGHT; m++) {
        var oRow = new Array();
        var zRow = new Array();
        for (var n = 0; n < CANVAS_WIDTH; n++) {
            oRow.push(" ");
            zRow.push(0);
        }
        output.push(oRow);
        zbuffer.push(zRow);
    }

    % Init the GUI
    initialiseButtons();

    % Start the animation interval
    animInterval = app.setInterval("runAll()", ANIMATION_SPEED);
}

/**
 * Initialise all buttons from the GUI.
 * For example add callbacks and set the correct colors.
 */
function initialiseButtons() {
    % Disables the rectangle around a button after the click
    app.focusRect = false;

    % Assign each button the coresponding function
    this.getField("restart").setAction("MouseUp", "restart();");
    this.getField("pause").setAction("MouseUp", "pause();");
    this.getField("resume").setAction("MouseUp", "resume();");

    % Tooltip setup
    this.getField("tooltipbtn").setAction("MouseDown", "tooltip(true);");
    this.getField("tooltipbtn").setAction("MouseUp", "tooltip(false);");
}

/**
 * Restarts the application by resetting the donut state.
 */
function restart() {
    A = 0;
    B = 0;
    resume();
}

/**
 * Pause the interval.
 */
function pause() {
    app.clearInterval(animInterval);
    animInterval = -1;
}

/**
 * Continue the interval.
 */
function resume() {
    if (animInterval == -1) {
        animInterval = app.setInterval("runAll()", ANIMATION_SPEED);
    }
}

/**
 * Enable or disable the tooltip.
 *
 * @param {Boolean} on Enable or disable tooltip.
 */
function tooltip(on) {
    if (on) {
        % Move the tooltip field to the center of the screen
        % and adjust the size so the text can be displayed
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = false;
        field.value = GAME_DESC;

        field.multiline = true;
        field.textSize = 16;
        % height 842, width 596
        % upper-left x, upper-left y, lower-right x and lower-right y
        field.rect = [128, 601, 468, 401];

        this.getField("tooltiptxt").setFocus();

        field.delay = false;
    } else {
        % Remove the field such that it is not visible
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = true;
        field.delay = false;
    }
}

%%%%%%%
% Run %
%%%%%%%
/**
 * Render loop that draws the frame.
 */
function runAll() {
    clearBuffer();
    % Create the data for the current frame
    renderFrame(A, B);
    % Since the canvas changes each frame everything needs to be redrawn
    draw();
    A += 0.04 * SCALE;
    B += 0.02 * SCALE;
}

/**
 * Clear the output and the zbuffer before rendering to it.
 */
function clearBuffer() {
    for (var m = 0; m < CANVAS_HEIGHT; m++) {
        for (var n = 0; n < CANVAS_WIDTH; n++) {
            output[m][n] = " ";
            zbuffer[m][n] = 0;
        }
    }
}

% https://www.a1k0n.net/2011/07/20/donut-math.html
const THETA_SPACING = 0.07;
const PHI_SPACING   = 0.02;

const R1 = 1;
const R2 = 2;
const K2 = 5;
% Calculate K1 based on screen size:
% the maximum x-distance occurs roughly at the edge of the torus,
% which is at x = R1 + R2, z = 0.
% We want that to be displaced 3/8ths of the width of the screen,
% which is 3/4th of the way from the center to the side of the screen.
% canvasWidth*3/8 = K1*(R1+R2)/(K2+0)
% canvasWidth*K2*3/(8*(R1+R2)) = K1
const K1 = CANVAS_WIDTH * K2 * 3 / (8 * (R1 + R2));

/**
 * Render the current frame given A and B to the
 * output array and the zbuffer.
 *
 * @param {Number} A
 * @param {Number} B
 */
function renderFrame(A, B) {
    % Precompute sines and cosines of A and B
    var cosA = Math.cos(A);
    var sinA = Math.sin(A);
    var cosB = Math.cos(B);
    var sinB = Math.sin(B);

    % Theta goes around the cross-sectional circle of a torus
    for (var theta = 0; theta < 2 * Math.PI; theta += THETA_SPACING) {
        % Precompute sines and cosines of theta
        var costheta = Math.cos(theta);
        var sintheta = Math.sin(theta);

        % Phi goes around the center of revolution of a torus
        for (var phi = 0; phi < 2 * Math.PI; phi += PHI_SPACING) {
            % Precompute sines and cosines of phi
            var cosphi = Math.cos(phi);
            var sinphi = Math.sin(phi);

            % The x, y coordinate of the circle, before revolving
            % (factored out of the above equations)
            var circlex = R2 + R1 * costheta;
            var circley = R1 * sintheta;

            % Final 3D (x, y, z) coordinate after rotations
            var x = circlex * (cosB * cosphi + sinA * sinB * sinphi)
                - circley * cosA * sinB;
            var y = circlex * (sinB * cosphi - sinA * cosB * sinphi)
                + circley * cosA * cosB;
            var z = K2 + cosA * circlex * sinphi + circley * sinA;
            var ooz = 1/z;

            % x and y projection.
            % Note that y is negated here, because y goes up in 3D space but down on 2D displays.
            var xp = Math.floor(CANVAS_WIDTH / 2 + K1 * ooz * x);
            var yp = Math.floor(CANVAS_HEIGHT / 2 - K1 * ooz * y);

            % Calculate luminance.
            var L = cosphi * costheta * sinB - cosA * costheta * sinphi -
                sinA * sintheta + cosB * (cosA * sintheta - costheta * sinA * sinphi);
            % L ranges from -sqrt(2) to +sqrt(2). If it's < 0, the surface
            % is pointing away from us, so we won't bother trying to plot it.
            if (L > 0) {
                % Test against the z-buffer. Larger 1/z means the pixel is
                % closer to the viewer than what's already plotted.
                if (ooz > zbuffer[xp][yp]) {
                    zbuffer[xp][yp] = ooz;
                    var luminanceIndex = L * 8;
                    % luminanceIndex is now in the range 0..11 (8*sqrt(2) = 11.3)
                    % now we lookup the character corresponding to the
                    % luminance and plot it in our output:
                    output[xp][yp] = CHAR_SET.charAt(luminanceIndex);
                }
            }
        }
    }
}

%%%%%%%%%%%%%%%%%%%%%
% Draw and coloring %
%%%%%%%%%%%%%%%%%%%%%
/**
 * Draw the current state of the canvas (output array)
 * to the display elements.
 */
function draw() {
    % Now, dump output[] to the screen.
    var cell;
    for (var m = 0; m < CANVAS_HEIGHT; m++) {
        for (var n = 0; n < CANVAS_WIDTH; n++) {
            cell = this.getField("cell" + m + "-" + n);
            cell.delay = true;
            cell.value = output[m][n];
            cell.delay = false;
        }
    }
}

\end{insDLJS}

\OpenAction{/S /JavaScript /JS (initialise();)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dokument
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

    \begin{Form}

        % Header
        \begin{multicols}{2}
            % Title
            \section*{Ascii Donut}
        \columnbreak
            % Tooltip object
            \begin{flushright}%
                \PushButton[name=tooltipbtn, bordercolor=, backgroundcolor=, borderwidth=0]{%
                    \begin{tcolorbox}[width=20pt, height=20pt, left=3pt, top=0pt]
                        \centering?\strut{}
                    \end{tcolorbox}%
                }
            \end{flushright}%
        \end{multicols}

        % Dynamically adjust the cell width to the number of cells per column
        % Only need to check width since the board is quadratic
        \FPeval{\resultW}{(\canvasWidth * 3 - 2)} % chktex 8
        \def\blocksizeW{\dimexpr (\linewidth-\resultW pt)/\canvasWidth \relax}

        % The canvas (pixelarray)
        \begin{tcolorbox}[colback=black]
            \begin{flushright}
                \xintFor* #1 in {\xintSeq{0}{\canvasHeight-1}} \do {%
                    \xintFor* #2 in {\xintSeq{0}{\canvasWidth-1}} \do {%
                        \TextField[
                            name=cell#1-#2, width=\blocksizeW, height=\blocksizeW,%
                            bordercolor=, backgroundcolor=, align=1, readonly%
                        ]{}%
                        \xintifForLast{}{\hspace{3pt}}%
                    }\vspace{3pt}%
                    \newline{}%
                }%
            \end{flushright}
        \end{tcolorbox}

        %%%%%%%%%%%%%%%%
        % GUI elements %
        %%%%%%%%%%%%%%%%
        % Game related buttons
        \begin{center}%
            \begin{tabularx}{\textwidth}{@{} *{3}{X} @{}}%
                \PushButton[name=restart, bordercolor=, backgroundcolor=, borderwidth=0]{
                    \begin{tcolorbox}
                        \centering
                        Restart\strut
                    \end{tcolorbox}
                } &
                \PushButton[name=pause, bordercolor=, backgroundcolor=, borderwidth=0]{
                    \begin{tcolorbox}
                        \centering
                        Pause\strut
                    \end{tcolorbox}
                } &
                \PushButton[name=resume, bordercolor=, backgroundcolor=, borderwidth=0]{
                    \begin{tcolorbox}
                        \centering
                        Resume\strut
                    \end{tcolorbox}
                }
            \end{tabularx}
        \end{center}

        \TextField[name=tooltiptxt, bordercolor=, backgroundcolor=gray, readonly, hidden]{}

    \end{Form}

\end{document}
