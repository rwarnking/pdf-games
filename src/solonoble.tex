\documentclass[12pt, a4paper, footexclude, headexclude]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[margin=0.5in]{geometry}

\usepackage[pdftex]{hyperref}
\usepackage{multicol}

\usepackage{xinttools}
\usepackage[nomessages]{fp}
\usepackage{tabularx}
\usepackage{tcolorbox}

\setlength{\parindent}{0pt}

% Einbindung von Javascript ins PDF
\usepackage[pdftex]{insdljs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Obacht: It is discuraged to use a field with size bigger than 15x15 since the pdf might get
% to slow to play
\def\fieldWidth{9}
\def\fieldHeight{9}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Javascript
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inhalt der Umgebung wird in JSDateiname.djs gespeichert und steht im PDF zur Verf√ºgung
\begin{insDLJS}[]{JSDateiname}{Solo Noble}

const GAME_DESC = "This game consists of a field of cells. On each of these but one a marble\
is placed. The goal is to reduce the marble count to one while placing this last marble\
on the one cell which is empty at the beginning of the game.\
A marble can be moved only by jumping over exactly one other marble onto an empty cell.\
The jumped over marble is removed and it is not allowed to jump diagonal.";

% Outside variables
const FIELD_WIDTH = AFMakeNumber(\fieldWidth);
const FIELD_HEIGHT = AFMakeNumber(\fieldHeight);
const SCREEN_TEXT_WIDTH = 300;

% Constants
const ANIMATION_SPEED = 500;
% For empty cells
const NONE = -1;
const EMPTY = 0;
const FULL = 1;

% Globals
% Animation interval variable
var run;
% The game field
var complField = new Array();
% Saves the last clicked cell
var currentCell = null;
% The index determining which field should be played
var fieldIdx = 0;

%%%%%%%%%% Field arrays %%%%%%%%%%
const FIELDS = [
    [ % English
        [NONE, NONE,  NONE,  NONE,  NONE,  NONE,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, NONE],
        [NONE, FULL,  FULL,  FULL, EMPTY,  FULL,  FULL,  FULL, NONE],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  NONE,  NONE,  NONE,  NONE,  NONE, NONE]
    ],
    [ % European
        [NONE, NONE,  NONE,  NONE,  NONE,  NONE,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  FULL,  FULL,  FULL,  FULL,  FULL,  NONE, NONE],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, NONE],
        [NONE, FULL,  FULL,  FULL, EMPTY,  FULL,  FULL,  FULL, NONE],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, NONE],
        [NONE, NONE,  FULL,  FULL,  FULL,  FULL,  FULL,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  NONE,  NONE,  NONE,  NONE,  NONE, NONE]
    ],
    [ % German
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [FULL, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, FULL],
        [FULL, FULL,  FULL,  FULL, EMPTY,  FULL,  FULL,  FULL, FULL],
        [FULL, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, FULL],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE]
    ],
    [ % Asymmetrical
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, FULL],
        [NONE, FULL,  FULL,  FULL, EMPTY,  FULL,  FULL,  FULL, FULL],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, FULL],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  NONE,  NONE,  NONE,  NONE,  NONE, NONE]
    ],
    [ % Diamond
        [NONE, NONE,  NONE,  NONE,  FULL,  NONE,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  FULL,  FULL,  FULL,  FULL,  FULL,  NONE, NONE],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, NONE],
        [FULL, FULL,  FULL,  FULL, EMPTY,  FULL,  FULL,  FULL, FULL],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, NONE],
        [NONE, NONE,  FULL,  FULL,  FULL,  FULL,  FULL,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  NONE,  FULL,  NONE,  NONE,  NONE, NONE]
    ]
]

% Symbol array
const MARBLE_SYMBOL = String.fromCharCode(0x25CF);

% How many marbles need to be placed
const MARBLE_COUNTS = [
    32, 36, 44, 38, 40
]

% Color data
var colors = new Array();

const HIGHLIGHT_COLOR = [ "RGB", 0.984, 0.800, 0.176 ];

%%%%%%%%%%
% Helper %
%%%%%%%%%%
/**
 * Returns a random number between 0 and the param.
 * @param {Number} max The upperbound
 */
function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 1].
 * https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
 *
 * @param {number} h The hue
 * @param {number} s The saturation
 * @param {number} l The lightness
 * @return {Array} The RGB representation
 */
function hslToRgb(h, s, l) {
    var r, g, b;

    % achromatic
    if (s == 0) {
        r = g = b = l;
    } else {
        var hue2rgb = function hue2rgb(p, q, t) {
            if (t < 0) t += 1.0;
            if (t > 1) t -= 1.0;
            if (t < 1.0/6.0) return p + (q - p) * 6.0 * t;
            if (t < 1.0/2.0) return q;
            if (t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
            return p;
        }

        var q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
        var p = 2.0 * l - q;
        r = hue2rgb(p, q, h + 1.0/3.0);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1.0/3.0);
    }

    return [ "RGB", r, g, b ];
}

/**
 * Generates the specified amount of colors and pushes
 * them to the colors array.
 * For generating the colors are selected using hsl
 * and afterwards transformed to rgb.
 *
 * @param {number} amount The amount of colors to generate
 * @param {number} saturation The saturation
 * @param {number} lightness The lightness
 */
function generateColors(saturation, lightness, amount) {
    var huedelta = 1.0 / amount;

    for (var j = 0; j < amount; j++) {
        var hue = j * huedelta;
        colors.push(hslToRgb(hue, saturation, lightness));
    }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initialisation and Restart %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/**
 * Initialise the default game state.
 */
function initialise() {
    % Init the GUI
    initialiseButtons();
    % Get the value of the choise menu
    fieldIdx = this.getField("cmLayout").currentValueIndices;

    % Create the field using the FIELDS array data
    var idx = 0;
    for (var row = 0; row < FIELD_HEIGHT; row++) {
        var tmp = new Array();
        for (var column = 0; column < FIELD_WIDTH; column++) {
            var colorIdx = -1;
            var cell = FIELDS[fieldIdx][row][column];
            if (cell == FULL) {
                colorIdx = idx;
                idx++;
            }
            tmp.push([cell, colorIdx]);
        }
        complField.push(tmp);
    }

    % Hide all cells that are not part of the field
    hideCells();
    % Generate a color for each marble
    generateColors(1.0, 0.5, MARBLE_COUNTS[fieldIdx]);

    drawAll();
}

/**
 * Initialise all buttons from the GUI.
 * For example add callbacks and set the correct colors.
 */
function initialiseButtons() {
    var field;
    % Disables the rectangle around a button after the click
    app.focusRect = false;

    % Assign each button the coresponding function and set the highlights
    this.getField("restart").setAction("MouseUp", "restart();");
    this.getField("restart").highlight="outline";

    this.getField("solve").setAction("MouseUp", "solve();");
    this.getField("solve").highlight="outline";

    this.getField("cmLayout").currentValueIndices = 0;

    % Each field needs to be connected to an input function
    var funcName = "fieldClicked";
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            var callbackName = funcName + "(" + x.toString() + "," + y.toString() + ");";
            field = this.getField("pos" + x + "-" + y);
            field.setAction("MouseDown", callbackName);
            field.textSize = SCREEN_TEXT_WIDTH / FIELD_WIDTH;
            field.alignment = "center";
        }
    }

    % Info field setup
    this.getField("info").textFont = font.Times;

    % Tooltip setup
    field = this.getField("tooltipbtn");
    field.setAction("MouseDown", "tooltip(true);");
    field.setAction("MouseUp", "tooltip(false);");
    field.highlight="none";

    printInfoText("Init");
}

/**
 * Restart the game and clear everything
 */
function restart() {
    printInfoText("Restart");

    currentCell = null;

    fieldIdx = this.getField("cmLayout").currentValueIndices;

    % Create the field choosing a random symbol for each field
    var colorIdx = 0;
    for (var row = 0; row < FIELD_HEIGHT; row++) {
        for (var column = 0; column < FIELD_WIDTH; column++) {
            var cell = FIELDS[fieldIdx][row][column];
            complField[row][column][0] = cell;
            if (cell == FULL) {
                complField[row][column][1] = colorIdx;
                colorIdx++;
            }
        }
    }

    % Disable left over highlights
    for (var row = 0; row < FIELD_HEIGHT; row++) {
        for (var column = 0; column < FIELD_WIDTH; column++) {
            highlight(column, row, false);
        }
    }

    % Hide all cells that are not part of the field
    hideCells();
    % Generate a color for each marble
    colors = [];
    generateColors(1.0, 0.5, MARBLE_COUNTS[fieldIdx]);

    drawAll();
}

/**
 * Enable or disable the tooltip
 *
 * @param {Boolean} on Enable or disable tooltip
 */
function tooltip(on) {
    if (on) {
        % Move the tooltip field to the center of the screen
        % and adjust the size so the text can be displayed
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.value = GAME_DESC;

        field.multiline = true;
        field.textSize = 16;
        field.fillColor = color.gray;
        % hight 842, width 596
        % upper-left x, upper-left y, lower-right x and lower-right y
        field.rect = [128, 601, 468, 401];

        field.delay = false;
    } else {
        % Remove the field such that it is not visible
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.value = "";

        field.multiline = false;
        field.fillColor = color.gray;
        field.rect = [0, 0, 0, 0];

        field.delay = false;
    }
}

%%%%%%%%%%%%%
% Gamelogic %
%%%%%%%%%%%%%
/**
 * Save and highlight the last field the user clicked on.
 * Selection is only removed after clicking on the same field.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function fieldClicked(x, y, ignore=false) {
    % Select cell if none selected
    if (currentCell === null) {
        if (complField[y][x][0] == FULL) {
            currentCell = [x, y];
            highlight(x, y, true);
        } else {
            printInfoText("Cell empty and not selectable.");
        }
    } % Deselect cell
    else if (currentCell[0] == x && currentCell[1] == y) {
        currentCell = null;
        highlight(x, y, false);
    } else {
        % If a cell if selected the new click is interpreted as the target cell
        % Calculate wether it is a valid target
        var diffX = currentCell[0] - x;
        var diffY = currentCell[1] - y;
        var absX = Math.abs(diffX);
        var absY = Math.abs(diffY);

        if (absX == 2 && absY == 0 || absX == 0 && absY == 2) {
            if (complField[y][x][0] == EMPTY) {
                var x2 = x + diffX / 2;
                var y2 = y + diffY / 2;

                if (complField[y2][x2][0] == FULL) {
                    highlight(currentCell[0], currentCell[1], false);
                    jump(x, y);
                    currentCell = null;
                } else {
                    printInfoText("No cell to jump over.");
                }
            } else {
                printInfoText("Cell occupied, select other cell.");
            }
        } else {
            printInfoText("Not in range, select other cell.");
        }
    }
}

/**
 * Place the currentCell content into the new cell
 * and remove the cell content inbetween.
 *
 * @param {Number} x1 The x position.
 * @param {Number} y1 The y position.
 */
function jump(x1, y1) {
    var x2 = currentCell[0];
    var y2 = currentCell[1];

    var diffX = x2 - x1;
    var diffY = y2 - y1;
    var x3 = x1 + diffX / 2;
    var y3 = y1 + diffY / 2;

    complField[y3][x3][0] = EMPTY;
    complField[y2][x2][0] = EMPTY;
    complField[y1][x1][0] = FULL;
    % Rewrite color information
    complField[y1][x1][1] = complField[y2][x2][1];
    complField[y3][x3][1] = -1;
    complField[y2][x2][1] = -1;
    draw(x1, y1);
    draw(x2, y2);
    draw(x3, y3);
    printInfoText("Jump successfull.");
}

/**
 * Solve the current field by calculating a valid path leading to one marble in the
 * right spot (depending on start field).
 * This is done by backtracking and testing possible moves.
 * https://ece.uwaterloo.ca/~dwharder/aads/Algorithms/Backtracking/Peg_solitaire/
 */
function solve() {
    jasd = 0;

    % Get movesToTry for all marbles and marble count
    var movesToTry = [];
    var mCount = 0;
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            if (complField[y][x][0] == FULL) {
                movesToTry = movesToTry.concat(getMoves([x, y]));
                mCount++;
            }
        }
    }

    % Start backtracking until a solution is found
    % or all possibilities where tested.
    var solution = testSolution(movesToTry, mCount);
    drawAll();
}

var jasd = 0;

/**
 * Use the current list of all valid moves to test each of them.
 * After a move is made the field is evaluated again until
 * the solution is either valid or confirmed as wrong.
 * Should the solution be wrong the move is reversed
 * and another move is tested.
 * Should no moves be left the field has no solution.
 *
 * @param {Array} movesToTry A list of currently valid moves.
 * @param {Number} marbleCount The current amount of marbles on the field.
 */
function testSolution(movesToTry, marbleCount) {
    % TODO safety check
    jasd++;
    if (jasd == 30000) return [true, []];

    % If there is only one marble check for success
    if (marbleCount <= 1) {
        if (complField[4][4][0] == FULL) {
            return [true, []];
        } else {
            return [false, []];
        }
    }

    % Try one move after the other
    var triedMoves = [];
    while (movesToTry.length > 0) {
        var move = movesToTry.pop();

        makeMove(move);

        % Get all new possible moves
        var newMoves = getAllMoves();

        var result = testSolution(newMoves, marbleCount-1);
        if (result[0]) {
            % Create finished path
            triedMoves.push(move);
            triedMoves = triedMoves.concat(result[1]);
            return [true, triedMoves];
        } else {
            reverseMove(move);
        }
    }

    return [false, []];
}

/**
 * Iterate all cells and check if there is a marble.
 * If there is calculate all valid moves for this marble.
 * @return A list of valid moves.
 */
function getAllMoves() {
    % Get movesToTry for all marbles
    var movesToTry = [];
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            if (complField[y][x][0] == FULL) {
                movesToTry = movesToTry.concat(getMoves([x, y]));
            }
        }
    }

    return movesToTry;
}

/**
 * Get all moves for the given position.
 * This is tested by checking in all directions,
 * if the cell is empty and there is a cell to jump over.
 * @param {Array} marble The position to check.
 */
function getMoves(marble) {
    var x = marble[0];
    var y = marble[1];
    var moves = [];

    if (x + 2 < FIELD_WIDTH && complField[y][x + 2][0] == EMPTY && complField[y][x + 1][0] == FULL) {
        moves.push([x, y, x + 2, y]);
    }
    if (x - 2 >= 0 && complField[y][x - 2][0] == EMPTY && complField[y][x - 1][0] == FULL) {
        moves.push([x, y, x - 2, y]);
    }
    if (y + 2 < FIELD_HEIGHT && complField[y + 2][x][0] == EMPTY && complField[y + 1][x][0] == FULL) {
        moves.push([x, y, x, y + 2]);
    }
    if (y - 2 >= 0 && complField[y - 2][x][0] == EMPTY && complField[y - 1][x][0] == FULL) {
        moves.push([x, y, x, y - 2]);
    }
    return moves;
}

/**
 * Execute the given move.
 * @param {Array} fromToArray Containing the x,y pos for source and target.
 */
function makeMove(fromToArray) {
    var x1 = fromToArray[0];
    var y1 = fromToArray[1];
    var x2 = fromToArray[2];
    var y2 = fromToArray[3];

    var diffX = x2 - x1;
    var diffY = y2 - y1;
    var x3 = x1 + diffX / 2;
    var y3 = y1 + diffY / 2;

    complField[y3][x3][0] = EMPTY;
    complField[y2][x2][0] = FULL;
    complField[y1][x1][0] = EMPTY;
}

/**
 * Reverse the given move.
 * @param {Array} fromToArray Containing the x,y pos for source and target.
 */
function reverseMove(fromToArray) {
    var x1 = fromToArray[0];
    var y1 = fromToArray[1];
    var x2 = fromToArray[2];
    var y2 = fromToArray[3];

    var diffX = x2 - x1;
    var diffY = y2 - y1;
    var x3 = x1 + diffX / 2;
    var y3 = y1 + diffY / 2;

    complField[y3][x3][0] = FULL;
    complField[y2][x2][0] = EMPTY;
    complField[y1][x1][0] = FULL;
}

%%%%%%%%%%%%%%%%%%%%%
% Draw and coloring %
%%%%%%%%%%%%%%%%%%%%%
/**
 * Hide all cells that are of type NONE.
 */
function hideCells() {
    var field;
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            field = this.getField("pos" + x + "-" + y);
            if (complField[y][x][0] == NONE) {
                field.hidden = true;
            } else {
                field.hidden = false;
            }
        }
    }
}

/**
 * Draw all fields.
 */
function drawAll() {
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            draw(x, y);
        }
    }
}

/**
 * Since only one field is updated with each input,
 * only this field needs to be redrawn.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function draw(x, y) {
    var field = this.getField("pos" + x + "-" + y);
    field.delay = true;

    var val = complField[y][x][0];
    if (val == FULL) {
        field.value = MARBLE_SYMBOL;
        %field.textColor = colors[complField[y][x][1]];
        field.textColor = color.black;
    } else {
        field.value = "";
        field.textColor = color.black;
    }
    field.delay = false;
}

/**
 * Enables or disables the highlight for
 * all cells in the field.
 *
 * @param {Boolean} enable Enables or disables highlight.
 */
function highlightAll(enable) {
    for (var row = 0; row < FIELD_HEIGHT; row++) {
        for (var column = 0; column < FIELD_WIDTH; column++) {
            highlight(column, row, enable);
        }
    }
}

/**
 * Enables or disables the highlight of the given cell.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 * @param {Boolean} enable If true enables the highlight
 * @param {Boolean} bomb If true enables the bombhighlight
 */
function highlight(x, y, enable) {
    var field = this.getField("pos" + x + "-" + y);
    field.delay = true;
    % Highlight the current taken move
    if (enable) {
        field.borderColor = HIGHLIGHT_COLOR;
    } else {
        field.borderColor = color.white;
    }
    field.delay = false;
}

/**
 * Print the current points of the player.
 */
function updatePoints() {
    var field = this.getField("pointstxt");
    field.delay = true;
    field.value = points;
    field.delay = false;
}

/**
 * Print information about the gamestate.
 */
function printInfoText(text) {
    var field = this.getField("info");
    field.delay = true;
    field.value = text;
    field.delay = false;
}

\end{insDLJS}

\OpenAction{/S /JavaScript /JS (initialise();)}
\newdimen\longline
\longline=\textwidth\advance\longline-6em
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dokument
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

    \begin{Form}

        % Header
        \begin{multicols}{2}
            % Title
            \section*{Solo Noble}
        \columnbreak
            % Tooltip object
            \begin{flushright}%
                \PushButton[name=tooltipbtn, bordercolor=white]{%
                    \begin{tcolorbox}[width=20pt, height=20pt, left=3pt, top=0pt]
                        \centering?\strut{}
                    \end{tcolorbox}%
                }
            \end{flushright}%
        \end{multicols}

        % Calculate the max width and height of a block
        \FPeval{\resultW}{(\fieldWidth * 4 + 3)}
        \def\blocksizeW{\dimexpr (\linewidth-\resultW pt)/\fieldWidth \relax}

        \FPeval{\resultH}{(\fieldHeight * 4 + 3)}
        \def\blocksizeH{\dimexpr (500 pt -\resultH pt)/\fieldHeight \relax}

        % Define the blocksize via the smaller amount
        \ifnum\blocksizeW<\blocksizeH
            \def\blocksize{\blocksizeW}
        \else
            \def\blocksize{\blocksizeH}
        \fi

        % The gamefield
        \begin{tcolorbox}
            \begin{flushright}
                \xintFor* #2 in {\xintSeq{0}{\fieldHeight-1}} \do {%
                    \xintFor* #1 in {\xintSeq{0}{\fieldWidth-1}} \do {%
                        \TextField[%
                            width=\blocksize, height=\blocksize,%
                            bordercolor=white, name=pos#1-#2, readonly]{}%
                    }\vspace{3pt}
                    \newline%
                }%
            \end{flushright}%
        \end{tcolorbox}

        %%%%%%%%%%%%%%%%%%%%%%%
        % Commandredifinition %
        % https://www.dickimaw-books.com/latex/admin/html/eforms.shtml
        %%%%%%%%%%%%%%%%%%%%%%%
        \def\DefaultHeightofText{14pt}
        \renewcommand*{\LayoutTextField}[2]{%
            \parbox[c][\DefaultHeightofText]{0.5\linewidth}{#1#2}%
        }

        %%%%%%%%%%%%%%%%
        % GUI elements %
        %%%%%%%%%%%%%%%%
        \begin{multicols}{2}
            \begin{tcolorbox}
                \ChoiceMenu[name=cmLayout, bordercolor=gray, width=2cm, combo]{Layout: }{%
                    English (33), European (37), German (45), Asymmetrical (39), Diamond (41)%
                }
            \end{tcolorbox}

            \PushButton[name=restart, bordercolor=, backgroundcolor=, borderwidth=0]{
                \begin{tcolorbox}
                    \centering
                    Restart game\strut{}
                \end{tcolorbox}
            }

            \columnbreak

            \PushButton[name=solve, bordercolor=, backgroundcolor=, borderwidth=0]{
                \begin{tcolorbox}
                    \centering
                    Solve game\strut
                \end{tcolorbox}
            }

            \begin{tcolorbox}
                \TextField[name=info, width=2\linewidth, bordercolor=, backgroundcolor=]{\strut}
            \end{tcolorbox}
        \end{multicols}

        \TextField[bordercolor=white, name=tooltiptxt, readonly]{}
    \end{Form}
\end{document}
