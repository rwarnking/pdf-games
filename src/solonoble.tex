\documentclass[12pt, a4paper]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[margin=0.5in]{geometry}

\usepackage[pdftex]{hyperref}
\usepackage{multicol}

\usepackage{xinttools}
\usepackage[nomessages]{fp}
\usepackage{tabularx}
\usepackage{tcolorbox}

\setlength{\parindent}{0pt}

\usepackage[pdftex]{insdljs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Obacht: These must not be changed, otherwise the game is not playable
\def\boardWidth{9}
\def\boardHeight{9}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Javascript
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{insDLJS}[]{JSDateiname}{solo-noble}

const GAME_DESC = "This game consists of a board of cells. On each of these but one a marble\
is placed. The goal is to reduce the marble count to one while placing this last marble\
on the one cell which is empty at the beginning of the game.\
A marble can be moved only by jumping over exactly one other marble onto an empty cell.\
The jumped over marble is removed and it is not allowed to jump diagonal.";

% Outside variables
const BOARD_WIDTH = AFMakeNumber(\boardWidth);
const BOARD_HEIGHT = AFMakeNumber(\boardHeight);
const SCREEN_TEXT_SIZE = 300;

% Constants
const ANIMATION_SPEED = 33;
const ANIMATION_OFFSET = 0.05;
% Index of the animation cell x and y
const ANIM_POS = BOARD_WIDTH - 1;
% Index of the cell that counts as a win
const W_POS_X = [4, 4, 4, 4, 4];
const W_POS_Y = [4, 2, 4, 4, 4];
% For empty cells
const NONE = -1;
const EMPTY = 0;
const FULL = 1;

% Globals
% Animation interval variable for jumping
var run;
var timestep = 0.0;
% The game board
var complBoard = new Array();
% Saves the last clicked cell
var currentCell = null;
% The amount of taken cells
var currentMarbleCount = 0;
% The index determining which board should be played
var boardIdx = 0;
var colorEnabled = true;
% Animation variable for solution
var runSol;
% Saving current solving step
var exeIndex = 0;
% The array of moves to execute/apply to the board
var exeMoves = [];

%%%%%%%%%% Board arrays %%%%%%%%%%
const BOARDS = [
    [ % English
        [NONE, NONE,  NONE,  NONE,  NONE,  NONE,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, NONE],
        [NONE, FULL,  FULL,  FULL, EMPTY,  FULL,  FULL,  FULL, NONE],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  NONE,  NONE,  NONE,  NONE,  NONE, NONE]
    ],
    [ % European
        [NONE, NONE,  NONE,  NONE,  NONE,  NONE,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  FULL,  FULL,  FULL,  FULL,  FULL,  NONE, NONE],
        [NONE, FULL,  FULL,  FULL, EMPTY,  FULL,  FULL,  FULL, NONE],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, NONE],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, NONE],
        [NONE, NONE,  FULL,  FULL,  FULL,  FULL,  FULL,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  NONE,  NONE,  NONE,  NONE,  NONE, NONE]
    ],
    [ % German
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [FULL, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, FULL],
        [FULL, FULL,  FULL,  FULL, EMPTY,  FULL,  FULL,  FULL, FULL],
        [FULL, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, FULL],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE]
    ],
    [ % Asymmetrical
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, FULL],
        [NONE, FULL,  FULL,  FULL, EMPTY,  FULL,  FULL,  FULL, FULL],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, FULL],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  NONE,  NONE,  NONE,  NONE,  NONE, NONE]
    ],
    [ % Diamond
        [NONE, NONE,  NONE,  NONE,  FULL,  NONE,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  FULL,  FULL,  FULL,  FULL,  FULL,  NONE, NONE],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, NONE],
        [NONE, FULL,  FULL,  FULL, EMPTY,  FULL,  FULL,  FULL, NONE],
        [NONE, FULL,  FULL,  FULL,  FULL,  FULL,  FULL,  FULL, NONE],
        [NONE, NONE,  FULL,  FULL,  FULL,  FULL,  FULL,  NONE, NONE],
        [NONE, NONE,  NONE,  FULL,  FULL,  FULL,  NONE,  NONE, NONE],
        [NONE, NONE,  NONE,  NONE,  FULL,  NONE,  NONE,  NONE, NONE]
    ]
]

%%%%%%%%%% Solutions %%%%%%%%%%
var solMoves = [
    [ % English
        [6, 4, 4, 4], [5, 6, 5, 4], [7, 5, 5, 5], [7, 3, 7, 5], [5, 4, 5, 6],
        [5, 7, 5, 5], [5, 3, 7, 3], [5, 1, 5, 3], [4, 5, 6, 5], [7, 5, 5, 5],
        [4, 7, 4, 5], [4, 5, 6, 5], [4, 3, 4, 5], [4, 1, 4, 3], [4, 3, 6, 3],
        [7, 3, 5, 3], [3, 5, 5, 5], [6, 5, 4, 5], [3, 7, 3, 5], [3, 4, 3, 6],
        [2, 3, 4, 3], [3, 1, 3, 3], [1, 5, 3, 5], [4, 5, 2, 5], [1, 3, 1, 5],
        [1, 5, 3, 5], [3, 6, 3, 4], [3, 4, 3, 2], [5, 3, 3, 3], [3, 2, 3, 4],
        [2, 4, 4, 4]
    ],
    [ % European
        [2, 3, 4, 3], [3, 1, 3, 3], [2, 5, 2, 3], [4, 5, 2, 5], [4, 3, 4, 5],
        [5, 2, 3, 2], [2, 3, 4, 3], [5, 1, 3, 1], [5, 5, 3, 5], [5, 4, 5, 2],
        [4, 7, 4, 5], [2, 2, 4, 2], [7, 5, 5, 5], [2, 6, 2, 4], [7, 3, 5, 3],
        [5, 2, 3, 2], [3, 1, 3, 3], [7, 4, 5, 4], [4, 5, 2, 5], [3, 7, 3, 5],
        [4, 3, 2, 3], [2, 5, 4, 5], [6, 6, 4, 6], [1, 3, 3, 3], [3, 3, 3, 5],
        [5, 4, 5, 6], [4, 5, 2, 5], [1, 4, 3, 4], [5, 7, 5, 5], [1, 5, 3, 5],
        [3, 4, 3, 6], [3, 6, 5, 6], [5, 6, 5, 4], [5, 4, 5, 2], [6, 2, 4, 2]
    ],
    [ % German
        [4, 2, 4, 4], [2, 3, 4, 3], [3, 5, 3, 3], [3, 2, 3, 4], [3, 0, 3, 2],
        [1, 5, 3, 5], [3, 5, 3, 3], [3, 3, 3, 1], [0, 3, 2, 3], [2, 3, 2, 5],
        [5, 5, 3, 5], [3, 5, 1, 5], [3, 7, 3, 5], [5, 6, 3, 6], [5, 8, 5, 6],
        [7, 5, 5, 5], [5, 5, 5, 7], [3, 8, 5, 8], [5, 8, 5, 6], [6, 3, 6, 5],
        [8, 3, 6, 3], [5, 3, 7, 3], [8, 5, 8, 3], [8, 3, 6, 3], [0, 5, 2, 5],
        [2, 5, 4, 5], [5, 0, 3, 0], [3, 0, 3, 2], [5, 1, 3, 1], [3, 1, 3, 3],
        [3, 3, 5, 3], [5, 3, 7, 3], [7, 3, 7, 5], [7, 5, 5, 5], [5, 5, 3, 5],
        [3, 5, 3, 7], [3, 7, 5, 7], [5, 7, 5, 5], [5, 5, 5, 3], [5, 2, 5, 4],
        [5, 4, 3, 4], [0, 4, 2, 4], [2, 4, 4, 4]
    ],
    [ % Asymmetrical
        [4, 2, 4, 4], [4, 0, 4, 2], [6, 3, 4, 3], [8, 3, 6, 3], [8, 5, 8, 3],
        [7, 5, 7, 3], [5, 4, 7, 4], [5, 5, 7, 5], [7, 3, 5, 3], [7, 5, 7, 3],
        [8, 3, 6, 3], [5, 2, 5, 4], [3, 3, 5, 3], [6, 3, 4, 3], [4, 4, 6, 4],
        [2, 4, 4, 4], [1, 3, 3, 3], [3, 2, 3, 4], [3, 0, 3, 2], [4, 4, 2, 4],
        [1, 4, 3, 4], [3, 5, 3, 3], [5, 0, 5, 2], [3, 7, 3, 5], [3, 5, 5, 5],
        [1, 5, 3, 5], [5, 7, 3, 7], [3, 2, 3, 4], [3, 4, 3, 6], [3, 7, 3, 5],
        [5, 6, 3, 6], [3, 6, 3, 4], [4, 2, 4, 4], [3, 4, 5, 4], [5, 5, 5, 3],
        [5, 2, 5, 4], [6, 4, 4, 4]
    ],
    [ % Diamond http://recmath.org/pegsolitaire/gif/Hermarys23Move.gif
        [4, 2, 4, 4], [4, 5, 4, 3], [4, 7, 4, 5], [6, 2, 4, 2], [6, 6, 4, 6],
        [5, 4, 5, 2], [4, 5, 4, 7], [5, 1, 5, 3], [2, 6, 4, 6], [3, 4, 3, 6],
        [3, 7, 3, 5], [3, 2, 3, 4], [3, 4, 3, 6], [3, 6, 5, 6], [5, 6, 5, 4],
        [5, 4, 5, 2], [5, 2, 3, 2], [1, 5, 3, 5], [7, 5, 5, 5], [7, 3, 5, 3],
        [3, 1, 3, 3], [4, 0, 4, 2], [1, 4, 3, 4], [3, 4, 3, 2], [3, 2, 5, 2],
        [5, 2, 5, 4], [5, 4, 5, 6], [1, 3, 3, 3], [5, 7, 5, 5], [4, 8, 4, 6],
        [7, 4, 5, 4], [5, 4, 5, 6], [5, 6, 3, 6], [3, 6, 3, 4], [3, 4, 3, 2],
        [2, 2, 4, 2], [4, 2, 4, 4]
    ]
];

% Symbols
const MARBLE_SYMBOL = String.fromCharCode(0x25CF);
const EMPTY_SYMBOL = String.fromCharCode(0x25CB);

% How many marbles need to be placed
const MARBLE_COUNTS = [
    32, 36, 44, 38, 40
]

% Color data
var colors = new Array();

const HIGHLIGHT_COLOR = [ "RGB", 0.984, 0.800, 0.176 ];

%%%%%%%%%%
% Helper %
%%%%%%%%%%
/**
 * Returns a random number between 0 and the parameter.
 * @param {Number} max The upper bound
 */
function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 1].
 * https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
 *
 * @param {number} h The hue
 * @param {number} s The saturation
 * @param {number} l The lightness
 * @return {Array} The RGB representation
 */
function hslToRgb(h, s, l) {
    var r, g, b;

    % achromatic
    if (s == 0) {
        r = g = b = l;
    } else {
        var hue2rgb = function hue2rgb(p, q, t) {
            if (t < 0) t += 1.0;
            if (t > 1) t -= 1.0;
            if (t < 1.0/6.0) return p + (q - p) * 6.0 * t;
            if (t < 1.0/2.0) return q;
            if (t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
            return p;
        }

        var q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
        var p = 2.0 * l - q;
        r = hue2rgb(p, q, h + 1.0/3.0);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1.0/3.0);
    }

    return [ "RGB", r, g, b ];
}

/**
 * Generates the specified amount of colors and pushes
 * them to the colors array.
 * For generating the colors are selected using HSL
 * and afterwards transformed to RGB.
 *
 * @param {number} amount The amount of colors to generate
 * @param {number} saturation The saturation
 * @param {number} lightness The lightness
 */
function generateColors(saturation, lightness, amount) {
    var huedelta = 1.0 / amount;

    for (var j = 0; j < amount; j++) {
        var hue = j * huedelta;
        colors.push(hslToRgb(hue, saturation, lightness));
    }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initialization and Restart %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/**
 * Initialize the default game state.
 */
function initialise() {
    % Init the GUI
    initialiseButtons();
    % Get the value of the choise menu
    boardIdx = this.getField("cmLayout").currentValueIndices;
    currentMarbleCount = MARBLE_COUNTS[boardIdx];

    % Create the board using the BOARDS array data
    var idx = 0;
    for (var row = 0; row < BOARD_HEIGHT; row++) {
        var tmp = new Array();
        for (var column = 0; column < BOARD_WIDTH; column++) {
            var colorIdx = -1;
            var cell = BOARDS[boardIdx][row][column];
            if (cell == FULL) {
                colorIdx = idx;
                idx++;
            }
            tmp.push([cell, colorIdx]);
        }
        complBoard.push(tmp);
    }

    % Hide all cells that are not part of the board
    hideCells();
    % Generate a color for each marble
    generateColors(1.0, 0.5, currentMarbleCount);

    drawAll();
}

/**
 * Initialize all buttons from the GUI.
 * For example add callbacks and set the correct colors.
 */
function initialiseButtons() {
    % Disables the rectangle around a button after the click
    app.focusRect = false;

    this.getField("cbColor").checkThisBox(0);

    % Assign each button the coresponding function and set the highlights
    this.getField("restart").setAction("MouseUp", "restart();");

    this.getField("showSol").setAction("MouseUp", "showSolution();");

    this.getField("import").setAction("MouseUp", "importBoard();");
    this.getField("export").setAction("MouseUp", "exportBoard();");

    this.getField("exmoves").setAction("MouseUp", "executeMoves();");

    this.getField("cmLayout").currentValueIndices = 0;

    % Each cell needs to be connected to an input function
    var cell;
    var funcName = "cellClicked";
    for (var x = 0; x < BOARD_WIDTH; x++) {
        for (var y = 0; y < BOARD_HEIGHT; y++) {
            var callbackName = funcName + "(" + x.toString() + "," + y.toString() + ");";
            cell = this.getField("pos" + x + "-" + y);
            cell.setAction("MouseDown", callbackName);
            cell.textSize = SCREEN_TEXT_SIZE / Math.max(BOARD_HEIGHT, BOARD_WIDTH);
        }
    }

    % Info field setup
    this.getField("info").textFont = font.Times;

    % Tooltip setup
    this.getField("tooltipbtn").setAction("MouseDown", "tooltip(true);");
    this.getField("tooltipbtn").setAction("MouseUp", "tooltip(false);");

    printInfoText("Init");
}

/**
 * Restart the game and clear everything
 */
function restart() {
    printInfoText("Restart");

    % Stop showing solution if in process
    if (exeIndex != 0) {
        app.clearInterval(runSol);
        exeIndex = 0;
    }

    currentCell = null;

    boardIdx = this.getField("cmLayout").currentValueIndices;
    currentMarbleCount = MARBLE_COUNTS[boardIdx];

    % Reset the board
    var colorIdx = 0;
    for (var row = 0; row < BOARD_HEIGHT; row++) {
        for (var column = 0; column < BOARD_WIDTH; column++) {
            var cell = BOARDS[boardIdx][row][column];
            complBoard[row][column][0] = cell;
            if (cell == FULL) {
                complBoard[row][column][1] = colorIdx;
                colorIdx++;
            }
        }
    }

    % Disable left over highlights
    for (var row = 0; row < BOARD_HEIGHT; row++) {
        for (var column = 0; column < BOARD_WIDTH; column++) {
            highlight(column, row, false);
        }
    }

    % Hide all cells that are not part of the board
    hideCells();

    colorEnabled = this.getField("cbColor").isBoxChecked(0);
    if (colorEnabled) {
        % Generate a color for each marble
        colors = [];
        generateColors(1.0, 0.5, currentMarbleCount);
    }

    drawAll();
}

/**
 * Enable or disable the tooltip.
 *
 * @param {Boolean} on Enable or disable tooltip.
 */
function tooltip(on) {
    if (on) {
        % Move the tooltip field to the center of the screen
        % and adjust the size so the text can be displayed
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = false;
        field.value = GAME_DESC;

        field.multiline = true;
        field.textSize = 16;
        % height 842, width 596
        % upper-left x, upper-left y, lower-right x and lower-right y
        field.rect = [128, 601, 468, 401];

        this.getField("tooltiptxt").setFocus();

        field.delay = false;
    } else {
        % Remove the field such that it is not visible
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = true;
        field.delay = false;
    }
}

%%%%%%%%%%%%%
% Gamelogic %
%%%%%%%%%%%%%
/**
 * Save and highlight the last cell the user clicked on.
 * Selection is only removed after clicking on the same cell.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function cellClicked(x, y, ignore=false) {
    this.getField("exporttxt").setFocus();

    if (timestep != 0.0) {
        printInfoText("Please wait for animation.");
        return;
    }

    % Select cell if none selected
    if (currentCell === null) {
        if (complBoard[y][x][0] == FULL) {
            currentCell = [x, y];
            highlight(x, y, true);
        } else {
            printInfoText("Cell empty and not selectable.");
        }
    } % Deselect cell
    else if (currentCell[0] == x && currentCell[1] == y) {
        currentCell = null;
        highlight(x, y, false);
    } else {
        % If a cell if selected the new click is interpreted as the target cell
        % Calculate wether it is a valid target
        var diffX = currentCell[0] - x;
        var diffY = currentCell[1] - y;
        var absX = Math.abs(diffX);
        var absY = Math.abs(diffY);

        if (absX == 2 && absY == 0 || absX == 0 && absY == 2) {
            if (complBoard[y][x][0] == EMPTY) {
                var x2 = x + diffX / 2;
                var y2 = y + diffY / 2;
                % Actually do stuff
                if (complBoard[y2][x2][0] == FULL) {
                    highlight(currentCell[0], currentCell[1], false);
                    jump(x, y);
                    currentCell = null;
                } else {
                    printInfoText("No cell to jump over.");
                }
            } else {
                printInfoText("Cell occupied, select other cell.");
            }
        } else {
            printInfoText("Not in range, select other cell.");
        }
    }
}

/**
 * Place the currentCell content into the new cell
 * and remove the cell content in between.
 *
 * @param {Number} x1 The x position.
 * @param {Number} y1 The y position.
 */
function jump(x1, y1) {
    currentMarbleCount--;

    var x2 = currentCell[0];
    var y2 = currentCell[1];

    % Calculate cell in between
    var diffX = x2 - x1;
    var diffY = y2 - y1;
    var x3 = x1 + diffX / 2;
    var y3 = y1 + diffY / 2;

    complBoard[y3][x3][0] = EMPTY;
    complBoard[y2][x2][0] = EMPTY;
    complBoard[y1][x1][0] = FULL;
    % Rewrite color information
    complBoard[y1][x1][1] = complBoard[y2][x2][1];
    complBoard[y3][x3][1] = -1;
    complBoard[y2][x2][1] = -1;

    % Prepare the animation cell
    complBoard[ANIM_POS][ANIM_POS][0] = FULL;
    complBoard[ANIM_POS][ANIM_POS][1] = complBoard[y1][x1][1];
    draw(ANIM_POS, ANIM_POS);

    % Start animation
    var callback = "jumpAnimation(" + x1 + "," + y1 + "," + x2 + "," + y2 + "," + x3 + "," + y3 + ")";
    run = app.setInterval(callback, ANIMATION_SPEED);
}

/**
 * Function for an animated cell. The cell is moved between two
 * given positions by linear interpolation.
 * The start position and the center position are redrawn at
 * appropriate times.
 *
 * @param {Number} x1 The target x position.
 * @param {Number} y1 The target y position.
 * @param {Number} x2 The source x position.
 * @param {Number} y2 The source y position.
 * @param {Number} x3 The center x position.
 * @param {Number} y3 The center y position.
 */
function jumpAnimation(x1, y1, x2, y2, x3, y3) {
    % Get animation cell
    var cell = this.getField("pos" + ANIM_POS + "-" + ANIM_POS);

    % Stop animation and reset if time limit is reached
    if (timestep >= 1.0) {
        timestep = 0.0;
        draw(x1, y1);
        cell.hidden = true;
        complBoard[ANIM_POS][ANIM_POS][0] = NONE;
        if (getAllMoves().length > 0) {
            printInfoText("Jump successfull!");
        } else {
            var lastPos = complBoard[W_POS_Y[boardIdx]][W_POS_X[boardIdx]][0] == FULL;
            if (currentMarbleCount == 1 && lastPos) {
                printInfoText("Game over, you won!");
            } else {
                printInfoText("Game over, no moves left!");
            }
        }
        app.clearInterval(run);
        return;
    }
    % If precisely at the center of the line draw pos 3 (remove marble)
    if (timestep >= 0.5 && timestep <= 0.5 + ANIMATION_OFFSET) {
        draw(x3, y3);
    } % Draw (remove) the start marble in the beginning
    else if (timestep >= 0.0 && timestep <= 0.0 + ANIMATION_OFFSET) {
        draw(x2, y2);
    }

    % Show the animation cell
    cell.hidden = false;

    % Get the cells for the rectangle
    var src = this.getField("pos" + x2 + "-" + y2);
    var tgt = this.getField("pos" + x1 + "-" + y1);
    % Move the rectangle
    var rect = [0, 0, 0, 0];
    for (var i = 0; i < 4; i++) {
        rect[i] = tgt.rect[i] * timestep + src.rect[i] * (1.0 - timestep);
    }
    cell.rect = rect;

    timestep += ANIMATION_OFFSET;
}

%%%%%%%%%%%%%%%%%
% Show Solution %
%%%%%%%%%%%%%%%%%
/**
 * Show a predefined solution for the start board.
 * Checking all possible moves like here
 * https://ece.uwaterloo.ca/~dwharder/aads/Algorithms/Backtracking/Peg_solitaire/
 * does not work for performance reasons.
 */
function showSolution() {
    % Prevent double execution due to multiple clicks on the GUI
    if (exeIndex != 0) {
        printInfoText("Solution already running!");
        return;
    }
    % Restart to ensure all marbles being there
    restart();

    var boardIdx = this.getField("cmLayout").currentValueIndices;
    exeMoves = solMoves[boardIdx];
    % Start animation
    var callback = "animateMoves()";
    runSol = app.setInterval(callback, ANIMATION_SPEED * (1.1 / ANIMATION_OFFSET));

    drawAll();
}

/**
 * Apply a specified sequence of moves to the board.
 * The moves need to be given via the GUI and need to be
 * in character-notation or matrix-notation (m1:n1-m2:n2).
 * It is possible to give any number of moves.
 */
function executeMoves() {
    % Reset focus since the button would yield the text window inoperative
    this.getField("exmovestxt").setFocus();
    % Prevent double execution due to multiple clicks on the GUI
    if (exeIndex != 0) {
        printInfoText("Moves are already executed!");
        return;
    }

    % Convert move string
    var moveSequence = this.getField("exmovestxt").value;
    exeMoves = stringToSolution(moveSequence);
    % Check for error
    if (exeMoves[0][0] == 0) {
        printInfoText("Moves not parseable!");
        return;
    }

    var callback = "animateMoves()";
    runSol = app.setInterval(callback, ANIMATION_SPEED * (1.1 / ANIMATION_OFFSET));

    drawAll();
}

/**
 * Animates the current move (exeIndex) from the exeMoves array.
 * The same function is called as if the cells are would be clicked on.
 * Clears the interval after applying all steps.
 */
function animateMoves() {
    % Security measure to ensure no execution while move animation is running
    if (timestep != 0.0) {
        return;
    }
    % Stop the animation
    if (exeIndex >= exeMoves.length) {
        exeIndex = 0;
        app.clearInterval(runSol);
        return;
    }
    % Execute move by simulate a click on the cells
    cellClicked(exeMoves[exeIndex][0], exeMoves[exeIndex][1]);
    cellClicked(exeMoves[exeIndex][2], exeMoves[exeIndex][3]);
    % Reset the cell state if the move was not executable
    currentCell = null;
    highlight(exeMoves[exeIndex][0], exeMoves[exeIndex][1], false);
    highlight(exeMoves[exeIndex][2], exeMoves[exeIndex][3], false);
    exeIndex++;
}

/**
 * Converts a given string into a sequence of array positions.
 * The string needs to refer to the cells via character notation.
 * Obacht: Does only work for English and European layout!
 * @param {String} moveSequence The sequence of moves to convert.
 * @return {Array} An array of fromTo positions or [[0]] if not parseable.
 */
function stringToSolution(moveSequence) {
    var toIdx = function toIdx(cell) {
        % The char notation table
        var charRep = [
            [0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 'a', 'b', 'c', 0, 0, 0],
            [0, 0, 'y', 'd', 'e', 'f', 'z', 0, 0],
            [0, 'g', 'h', 'i', 'j', 'k', 'l', 'm', 0],
            [0, 'n', 'o', 'p', 'x', 'P', 'O', 'N', 0],
            [0, 'M', 'L', 'K', 'J', 'I', 'H', 'G', 0],
            [0, 0, 'Z', 'F', 'E', 'D', 'Y', 0, 0],
            [0, 0, 0, 'C', 'B', 'A', 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0]
        ];
        % Search for the currently wanted char in the table
        % and return its coordinates
        for (var y = 0; y < charRep.length; y++) {
            for (var x = 0; x < charRep[y].length; x++) {
                if (cell == charRep[y][x]) {
                    return [x, y];
                }
            }
        }
        % Indicate error if not found
        return [0];
    }

    var result = [];
    var moves = moveSequence.split(/[,\/]/);

    % Check for notation type
    if (moves[0][0] >= '0' && moves[0][0] <= '9') {
        for (var x = 0; x < moves.length; x++) {
            % Get both positions
            var pos = moves[x].split("-");
            % Indicate error
            if (pos.length != 2) {
                return [[0]];
            }
            % Get coordinates
            var from = pos[0].split(":");
            var to = pos[1].split(":");
            % Indicate error
            if (from.length != 2 || to.length != 2) {
                return [[0]];
            }

            % Care input x, y are swapped
            result.push([
                parseInt(from[1], 10) + 1,
                parseInt(from[0], 10) + 1,
                parseInt(to[1], 10) + 1,
                parseInt(to[0], 10) + 1
            ]);
        }
    } else {
        for (var i = 0; i < moves.length; i++) {
            var from = toIdx(moves[i][0]);
            var to = toIdx(moves[i][1]);
            % Indicate error if not found
            if (from[0] == 0 || to[0] == 0 || moves[i].length != 2) {
                return [[0]];
            }
            % Create a fromTo move array
            result.push([from[0], from[1], to[0], to[1]]);
        }
    }

    return result;
}

/**
 * Iterate all cells and check if there is a marble.
 * If there is calculate all valid moves for this marble.
 * @return A list of valid moves.
 */
function getAllMoves() {
    % Get movesToTry for all marbles
    var movesToTry = [];
    for (var x = 0; x < BOARD_WIDTH; x++) {
        for (var y = 0; y < BOARD_HEIGHT; y++) {
            if (complBoard[y][x][0] == FULL) {
                movesToTry = movesToTry.concat(getMoves([x, y]));
            }
        }
    }

    return movesToTry;
}

/**
 * Get all moves for the given position.
 * This is tested by checking in all directions,
 * if the cell is empty and there is a cell to jump over.
 * @param {Array} marble The position to check.
 */
function getMoves(marble) {
    var x = marble[0];
    var y = marble[1];
    var moves = [];

    % Check each of the four directions + out of bounds
    if (x + 2 < BOARD_WIDTH && complBoard[y][x + 2][0] == EMPTY && complBoard[y][x + 1][0] == FULL) {
        moves.push([x, y, x + 2, y]);
    }
    if (x - 2 >= 0 && complBoard[y][x - 2][0] == EMPTY && complBoard[y][x - 1][0] == FULL) {
        moves.push([x, y, x - 2, y]);
    }
    if (y + 2 < BOARD_HEIGHT && complBoard[y + 2][x][0] == EMPTY && complBoard[y + 1][x][0] == FULL) {
        moves.push([x, y, x, y + 2]);
    }
    if (y - 2 >= 0 && complBoard[y - 2][x][0] == EMPTY && complBoard[y - 1][x][0] == FULL) {
        moves.push([x, y, x, y - 2]);
    }
    return moves;
}

%%%%%%%%%%%%%%%%%%%%%
% Import and export %
%%%%%%%%%%%%%%%%%%%%%
/**
 * Print a unique number to the GUI as board representation.
 */
function exportBoard() {
    % Reset focus since the button would yield the text window inoperative
    this.getField("exporttxt").setFocus();
    if (timestep != 0.0) {
        printInfoText("Can not export while jumping!");
        return;
    }
    this.getField("exporttxt").value = getUniqueCombination();
    printInfoText("Exported!");
}

/**
 * Get a number as unique board representation.
 * Each bit representing one cell of the board.
 * @return {Number} A representative of the board.
 */
function getUniqueCombination() {
    var arrayNum = 0;
    for (var x = 0; x < BOARD_WIDTH; x++) {
        for (var y = 0; y < BOARD_HEIGHT; y++) {
            if (complBoard[y][x][0] == NONE) {
                continue;
            }
            % Shift operation do not work - to many bits needed
            arrayNum *= 2;
            if (complBoard[y][x][0] == FULL) {
                arrayNum += 1;
            }
        }
    }
    return arrayNum;
}

/**
 * Read the input from the GUI to generate a board from a
 * number representation.
 * OBACHT: Different layouts are not compatible.
 */
function importBoard() {
    % Stop showing solution if in process
    if (exeIndex != 0) {
        app.clearInterval(runSol);
        exeIndex = 0;
    }

    % Reset focus since the button would yield the txt window inoperative
    this.getField("importtxt").setFocus();
    var boardIdx = this.getField("cmLayout").currentValueIndices;
    var combination = this.getField("importtxt").value;
    if (MARBLE_COUNTS[boardIdx] < cellCount(combination)) {
        printInfoText("Input not compatible with current selected layout.");
        return;
    }
    toBoard(combination);
    drawAll();
    printInfoText("Imported!");
}

/**
 * Uses the given board to set the cells of the displayed board.
 * @param {Number} combination A representation of the board.
 */
function toBoard(combination) {
    var res = combination;
    % Iterate from back to front because of leading zeros
    for (var x = BOARD_WIDTH - 1; x >= 0; x--) {
        for (var y = BOARD_HEIGHT - 1; y >= 0 ; y--) {
            if (complBoard[y][x][0] == NONE) {
                continue;
            }

            var val = res \% 2;
            if (val == 1) {
                complBoard[y][x][0] = FULL;
                res -= 1;
            } else {
                complBoard[y][x][0] = EMPTY;
            }
            res = res / 2;
        }
    }
}

/**
 * Get the amount of used cells that are in this board.
 * For this the amount of ones of the binary form are counted.
 * @param {Number} combination A number representation of the board.
 * @return {Number} The amount of used cells.
 */
function cellCount(combination) {
    var count = 0;
    % Get one bit after the other
    while (combination > 0) {
        var val = combination \% 2;
        if (val == 1) {
            count++;
            combination -= 1;
        }
        combination = combination / 2;
    }
    return count;
}

%%%%%%%%%%%%%%%%%%%%%
% Draw and coloring %
%%%%%%%%%%%%%%%%%%%%%
/**
 * Hide all cells that are of type NONE.
 */
function hideCells() {
    var cell;
    for (var x = 0; x < BOARD_WIDTH; x++) {
        for (var y = 0; y < BOARD_HEIGHT; y++) {
            cell = this.getField("pos" + x + "-" + y);
            if (complBoard[y][x][0] == NONE) {
                cell.hidden = true;
            } else {
                cell.hidden = false;
            }
        }
    }
}

/**
 * Draw all cells.
 */
function drawAll() {
    for (var x = 0; x < BOARD_WIDTH; x++) {
        for (var y = 0; y < BOARD_HEIGHT; y++) {
            draw(x, y);
        }
    }
}

/**
 * Since only one cell is updated with each input,
 * only this cell needs to be redrawn.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function draw(x, y) {
    var cell = this.getField("pos" + x + "-" + y);
    cell.delay = true;

    var val = complBoard[y][x][0];
    if (val == FULL) {
        cell.value = MARBLE_SYMBOL;
        if (colorEnabled) {
            cell.textColor = colors[complBoard[y][x][1]];
        } else {
            cell.textColor = color.black;
        }
    } else {
        cell.value = EMPTY_SYMBOL;
        cell.textColor = color.black;
    }
    cell.delay = false;
}

/**
 * Enables or disables the highlight for
 * all cells on the board.
 *
 * @param {Boolean} enable Enables or disables highlight.
 */
function highlightAll(enable) {
    for (var row = 0; row < BOARD_HEIGHT; row++) {
        for (var column = 0; column < BOARD_WIDTH; column++) {
            highlight(column, row, enable);
        }
    }
}

/**
 * Enables or disables the highlight of the given cell.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 * @param {Boolean} enable If true enables the highlight
 */
function highlight(x, y, enable) {
    var cell = this.getField("pos" + x + "-" + y);
    cell.delay = true;
    % Highlight the current taken move
    if (enable) {
        cell.borderColor = HIGHLIGHT_COLOR;
    } else {
        cell.borderColor = color.transparent;
    }
    cell.delay = false;
}

/**
 * Print the current points of the player.
 */
function updatePoints() {
    var field = this.getField("pointstxt");
    field.delay = true;
    field.value = points;
    field.delay = false;
}

/**
 * Print information about the gamestate.
 */
function printInfoText(text) {
    var field = this.getField("info");
    field.delay = true;
    field.value = text;
    field.delay = false;
}

\end{insDLJS}

\OpenAction{/S /JavaScript /JS (initialise();)}
\newdimen\longline
\longline=\textwidth\advance\longline-6em
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dokument
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

    \begin{Form}

        % Header
        \begin{multicols}{2}
            % Title
            \section*{Solo Noble}
        \columnbreak
            % Tooltip object
            \begin{flushright}%
                \PushButton[name=tooltipbtn, bordercolor=, backgroundcolor=, borderwidth=0]{%
                    \begin{tcolorbox}[width=20pt, height=20pt, left=3pt, top=0pt]
                        \centering?\strut{}
                    \end{tcolorbox}%
                }
            \end{flushright}%
        \end{multicols}

        % Dynamically adjust the cell width and height to the number of cells
        % Calculate the max width and height of a cell
        \FPeval{\resultW}{\boardWidth * 3 - 2} % chktex 8
        \def\cellWidth{\dimexpr (\linewidth-\resultW pt)/\boardWidth \relax}

        \FPeval{\resultH}{\boardHeight * 3 + 3}
        \def\cellHeight{\dimexpr (500 pt -\resultH pt)/\boardHeight \relax}

        % The game board
        \begin{tcolorbox}
            % Define the cell size via the smaller amount
            % Must be done here so the \linewidth has the correct value
            \ifdim\cellWidth<\cellHeight
                \def\cellsize{\cellWidth}
            \else
                \def\cellsize{\cellHeight}
            \fi

            \begin{center}
                \tiny
                \xintFor* #2 in {\xintSeq{0}{\boardHeight-1}} \do {%
                    \xintFor* #1 in {\xintSeq{0}{\boardWidth-1}} \do {%
                        \TextField[%
                            name=pos#1-#2, width=\cellsize, height=\cellsize,%
                            bordercolor=, backgroundcolor=, align=1, readonly%
                        ]{}%
                        \xintifForLast{}{\hspace{3pt}}%
                    }\vspace{3pt}\\[-1pt]%
                }%
            \end{center}%
        \end{tcolorbox}

        %%%%%%%%%%%%%%%%%%%%%%%
        % Commandredifinition %
        % https://www.dickimaw-books.com/latex/admin/html/eforms.shtml
        %%%%%%%%%%%%%%%%%%%%%%%
        \def\DefaultHeightofText{14pt}
        \renewcommand*{\LayoutTextField}[2]{%
            \parbox[c][\DefaultHeightofText]{0.5\linewidth}{#1#2}%
        }

        \renewcommand*{\LayoutCheckField}[2]{#1 #2}
        \renewcommand*{\DefaultWidthofCheckBox}{2ex}
        \renewcommand*{\DefaultHeightofCheckBox}{2ex}
        \renewcommand*{\LayoutCheckField}[2]{%
            \parbox[c][\DefaultHeightofCheckBox]{0.12\linewidth}{#1}\enspace%
            \parbox[c][\DefaultHeightofCheckBox]{\DefaultWidthofCheckBox}{#2}%
        }

        \renewcommand*{\DefaultWidthofChoiceMenu}{2.5ex}
        \renewcommand*{\DefaultHeightofChoiceMenu}{2.04ex}

        %%%%%%%%%%%%%%%%
        % GUI elements %
        %%%%%%%%%%%%%%%%
        \begin{tabularx}{\textwidth}{@{} *{2}{X} @{}}%
            \PushButton[name=restart, bordercolor=, backgroundcolor=, borderwidth=0]{
                \begin{tcolorbox}
                    \centering
                    Restart game\strut{}
                \end{tcolorbox}
            }
            &
            \PushButton[name=showSol, bordercolor=, backgroundcolor=, borderwidth=0]{
                \begin{tcolorbox}
                    \centering
                    Restart and show full solution\strut{}
                \end{tcolorbox}
            }
            \\
            \PushButton[name=exmoves, bordercolor=, backgroundcolor=, borderwidth=0]{
                \begin{tcolorbox}
                    \centering
                    Execute moves: \strut{}
                    \TextField[name=exmovestxt,
                        bordercolor=gray, borderwidth=2pt, backgroundcolor=white]{\strut}
                \end{tcolorbox}
            }
            &
            \begin{tcolorbox}
                \TextField[name=info, width=2\linewidth,
                    bordercolor=, backgroundcolor=, readonly]{\strut}
            \end{tcolorbox}
            \\[-0.3cm]
            \PushButton[name=import, bordercolor=, backgroundcolor=, borderwidth=0]{
                \begin{tcolorbox}
                    \centering
                    Import board: \strut{}
                    \TextField[name=importtxt,
                        bordercolor=gray, borderwidth=2pt, backgroundcolor=white]{\strut}
                \end{tcolorbox}
            }%
            &
            \PushButton[name=export, bordercolor=, backgroundcolor=, borderwidth=0]{
                \begin{tcolorbox}
                    \centering
                    Export board: \strut{}
                    \TextField[name=exporttxt,
                        bordercolor=gray, borderwidth=2pt, backgroundcolor=white]{\strut}
                \end{tcolorbox}
            }
            \\
            \begin{tcolorbox}%
                \centering%
                \ChoiceMenu[name=cmLayout, bordercolor=gray, width=2cm, combo]{Layout: }{%
                    English (33), European (37), German (45), Asymmetrical (39), Hermary (39)%
                }%
            \end{tcolorbox}%
            &
            \begin{tcolorbox}
                \CheckBox[name=cbColor, bordercolor=gray, checkboxsymbol=5]{Color}
            \end{tcolorbox}
        \end{tabularx}

        \TextField[name=tooltiptxt, bordercolor=, backgroundcolor=gray, readonly, hidden]{}
    \end{Form}
\end{document}
