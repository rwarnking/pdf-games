\documentclass[12pt, a4paper, footexclude, headexclude]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[margin=0.5in]{geometry}

% \usepackage[utf8x]{inputenc}
% \usepackage[T1]{fontenc}
% \usepackage[ngerman]{babel}
% \usepackage{xcolor}
\usepackage[pdftex]{hyperref}
\usepackage{multicol}

\usepackage{xinttools}
\usepackage[nomessages]{fp}
\usepackage{tabularx}
\usepackage{tcolorbox}

\setlength{\parindent}{0pt}

% Einbindung von Javascript ins PDF
\usepackage[pdftex]{insdljs}
%\renewcommand{\MakeTextField}[2]{{\vbox to #2{\vfill\hbox to #1{\hrulefill}}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Obacht: It is discuraged to use a field with size bigger than 15x15 since the pdf might get
% to slow to play
\def\fieldWidth{15}
\def\fieldHeight{10}

% Max playercount is 5
\def\playerCount{5}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Javascript
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inhalt der Umgebung wird in JSDateiname.djs gespeichert und steht im PDF zur Verf√ºgung
\begin{insDLJS}[]{JSDateiname}{Match Three Puzzle}

const GAME_DESC = "Text.\
Text.\
Text.\
Text.\
Text.";

% Outside variables
const FIELD_WIDTH = AFMakeNumber(\fieldWidth);
const FIELD_HEIGHT = AFMakeNumber(\fieldHeight);
const SCREEN_TEXT_WIDTH = 300;

% Constants
const MAX_SYMBOLS = 5;

% Globals
% The game field
var complField = new Array();
% Saves the symbols for the current match
var cur_symbols = [];
% Saves the last clicked cell
var currentCell = null;

% Symbol array
const ALL_SYMBOLS = [
    0x260E, % telefon
    0x261E, % hand white
    0x261B, % hand black
    0x263B, % smilie
    0x266B, % note
    0x2702, % scissors
    0x2712, % pencil
    0x2706, % telefon2
    0x2707, % video
    0x2708, % plane
    0x2709, % mail
    0x2756, % diamond
    0x271F, % cross
    0x2717,
    0x274D,
    0x2730,
    0x2752,
    0x271C
];

% Color data
const COLORS = new Array(
    %[ "RGB", 0.843, 0.078, 0.058 ],
    %[ "RGB", 0.203, 0.603, 0.054 ],
    %[ "RGB", 0.078, 0.305, 0.560 ]
);

const HIGHLIGHT_COLOR = [ "RGB", 0.984, 0.800, 0.176 ];

%%%%%%%%%%
% Helper %
%%%%%%%%%%
/**
 * Returns a random number between 0 and the param.
 * @param {Number} max The upperbound
 */
function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initialisation and Restart %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/**
 * Initialise the default game state.
 */
function initialise() {
    % Init the GUI
    initialiseButtons();

    for (var i = 0; i < MAX_SYMBOLS; i++) {
        cur_symbols.push(String.fromCharCode(ALL_SYMBOLS[i]));
    }

    % Create the field choosing a random symbol for each field
    var elem, rnd;
    for (var row = 0; row < FIELD_HEIGHT; row++) {
        var tmp = new Array();
        for (var column = 0; column < FIELD_WIDTH; column++) {
            rnd = getRandomInt(cur_symbols.length);
            % UTF8 symbol and is the field removed
            tmp.push([rnd, [0, 0, 0, 0]]);
        }
        complField.push(tmp);
    }
    % Remove matches due to generation
    cleanupField();
    % Transform the indices in the field to symbols
    idxToSymbol();

    for (var row = 0; row < FIELD_HEIGHT; row++) {
        for (var column = 0; column < FIELD_WIDTH; column++) {
            complField[row][column][1][0] = getCount(column, row, 1, 0);
            complField[row][column][1][1] = getCount(column, row, 0, 1);
            complField[row][column][1][2] = getCount(column, row, -1, 0);
            complField[row][column][1][3] = getCount(column, row, 0, -1);
        }
    }

    drawAll();
}

/**
 * Initialise all buttons from the GUI.
 * For example add callbacks and set the correct colors.
 */
function initialiseButtons() {
    % Assign each button the coresponding function and disable the highlights
    this.getField("restart").setAction("MouseUp", "restart();");
    this.getField("restart").highlight="none";

    % Each field needs to be connected to an input function
    var funcName = "fieldClicked";
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            var callbackName = funcName + "(" + x.toString() + "," + y.toString() + ");";
            this.getField("pos" + x + "-" + y).setAction("MouseDown", callbackName);
            this.getField("pos" + x + "-" + y).textSize = SCREEN_TEXT_WIDTH / FIELD_WIDTH;
            this.getField("pos" + x + "-" + y).alignment = "center";

            var swapCallback = "swap" + "(" + x.toString() + "," + y.toString() + ");";
            this.getField("pos" + x + "-" + y).setAction("MouseEnter", swapCallback);
        }
    }

    % Info field setup
    this.getField("info").fillColor = color.transparent;
    this.getField("info").borderColor = color.transparent;

    % Tooltip setup
    this.getField("tooltipbtn").setAction("MouseDown", "tooltip(true);");
    this.getField("tooltipbtn").setAction("MouseUp", "tooltip(false);");
    this.getField("tooltipbtn").highlight="none";

    printInfoText("Init");
}

/**
 * Restart the game and clear everything
 */
function restart() {
    printInfoText("Restart");
}

/**
 * Enable or disable the tooltip
 *
 * @param {Boolean} on Enable or disable tooltip
 */
function tooltip(on) {
    if (on) {
        % Move the tooltip field to the center of the screen
        % and adjust the size so the text can be displayed
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.value = GAME_DESC;

        field.multiline = true;
        field.textSize = 16;
        field.fillColor = color.gray;
        % hight 842, width 596
        % upper-left x, upper-left y, lower-right x and lower-right y
        field.rect = [128, 601, 468, 401];

        field.delay = false;
    } else {
        % Remove the field such that it is not visible
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.value = "";

        field.multiline = false;
        field.fillColor = color.gray;
        field.rect = [0, 0, 0, 0];

        field.delay = false;
    }
}

%%%%%%%%%%%%%%%%%%%%
% Field Generation %
%%%%%%%%%%%%%%%%%%%%
/**
 * Remove all matches with three or more elements by iterating
 * the field and checking if there are two cellss with
 * the same symbol directly above or infront.
 * In that case change the symbol to one that is not in the neighbourhood.
 * OBACHT: Does not work with MAX_SYMBOLS < 5.
 * TODO replace this?
 */
function cleanupField() {
    % Cleanup is not possible below 5 symbols, since it would be
    % possible that there is no replacement symbol if each
    % neighbour is a different symbol
    if (MAX_SYMBOLS < 5) {
        return;
    }

    var elem;
    for (var row = 0; row < FIELD_HEIGHT; row++) {
        for (var column = 0; column < FIELD_WIDTH; column++) {
            elem = complField[row][column][0];
            if (column > 1 &&
                complField[row][column - 1][0] == elem &&
                complField[row][column - 2][0] == elem) {

                complField[row][column][0] = getReplacementSymbol(row, column);
                %highlight(column, row, true);
            }
            if (row > 1 &&
                complField[row - 1][column][0] == elem &&
                complField[row - 2][column][0] == elem) {

                complField[row][column][0] = getReplacementSymbol(row, column);
                %highlight(column, row, true);
            }
        }
    }
}

/**
 * Finds a replacement symbol for the given cell.
 * The neighbourhood is checked for accurring symbols.
 * These are ignored from the remaining symbols a
 * random one is selected.
 *
 * @param {Number} row The table row.
 * @param {Number} column The table column.
 */
function getReplacementSymbol(row, column) {
    var neighbourhood = [];
    for (var i = 0; i < MAX_SYMBOLS; i++) {
        neighbourhood.push(true);
    }

    % Save which symbols are disallowed
    if (column > 0) {
        neighbourhood[complField[row][column - 1][0]] = false;
    }
    if (column < FIELD_WIDTH - 1) {
        neighbourhood[complField[row][column + 1][0]] = false;
    }
    if (row > 0) {
        neighbourhood[complField[row - 1][column][0]] = false;
    }
    if (row < FIELD_HEIGHT - 1) {
        neighbourhood[complField[row + 1][column][0]] = false;
    }
    neighbourhood[complField[row][column][0]] = false;

    % Save the indices of the allowed symbols
    var indices = [];
    for (var i = 0; i < MAX_SYMBOLS; i++) {
        if (neighbourhood[i]) {
            indices.push(i);
        }
    }
    % Get random index
    var rnd = getRandomInt(indices.length);
    return indices[rnd];
}

/**
 * Uses the indices in the field array to access the symbol table
 * of the current playthrough and assignes the curresponding symbol
 * to the field array.
 */
function idxToSymbol() {
    for (var row = 0; row < FIELD_HEIGHT; row++) {
        for (var column = 0; column < FIELD_WIDTH; column++) {
            complField[row][column][0] = cur_symbols[complField[row][column][0]];
        }
    }
}

%%%%%%%%%%%%%
% Gamelogic %
%%%%%%%%%%%%%
/**
 * Save and highlight the last field the user clicked on.
 * Selection is only removed after clicking on the same field.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function fieldClicked(x, y) {
    if (currentCell === null) {
        currentCell = [x, y];
        highlight(x, y, true);
    } else if (currentCell[0] == x && currentCell[1] == y) {
        currentCell = null;
        highlight(x, y, false);
    }
    % Allow for multiple clicks on the same field
    % TODO change to invisible field?
    this.getField("tooltiptxt").setFocus();
}

/**
 * Swaps the given position with the currentCell, if:
 * 1. There is a currentCell
 * 2. The given position is in the 4-neighbourhood
 * 3. The swap would leed to a stone removal
 * Lifts highlight after swap.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function swap(x, y) {
    if (currentCell !== null) {
        % Check that only the 4-neighbourhood is valid
        if (Math.abs(x - currentCell[0]) + Math.abs(y - currentCell[1]) == 1) {
            % Swap contents
            var tmp = complField[currentCell[1]][currentCell[0]][0];
            complField[currentCell[1]][currentCell[0]][0] = complField[y][x][0];
            complField[y][x][0] = tmp;

            % Check if the swap was valid
            if (hasMatch(x, y) || hasMatch(currentCell[0], currentCell[1])) {
                printInfoText("Swapped stones!");
                % Redraw
                draw(x, y);
                draw(currentCell[0], currentCell[1]);
                % Start replacing stones
                replaceStones(x, y, currentCell[0], currentCell[1])
            % If it wasnt revert the swap
            } else {
                printInfoText("Swap not allowed!");
                % Swap contents back
                tmp = complField[currentCell[1]][currentCell[0]][0];
                complField[currentCell[1]][currentCell[0]][0] = complField[y][x][0];
                complField[y][x][0] = tmp;
            }
            % Remove last click and highlight
            fieldClicked(currentCell[0], currentCell[1]);
        }
    }
}

/**
 * Checks if the given position has a match with atleast 3 elements.
 * For this the direction counts are recalculated and used to
 * obtain the amount of identical neighbours.
 * If no match is found the original direction counts are reassigned.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 * @return {Boolean} true if a match is found false else.
 */
function hasMatch(x, y) {

    var tmpDirCounts = complField[y][x][1];
    getDirCounts(x, y);

    var dirXPos = complField[y][x][1][0] + complField[y][x][1][2];
    var dirYPos = complField[y][x][1][1] + complField[y][x][1][3];

    if (dirXPos > 1 || dirYPos > 1) {
        return true;
    } else {
        complField[y][x][1] = tmpDirCounts;
        return false;
    }
}

%%%%%%%%%%%%%%%%%%%%%
% Stone replacement %
%%%%%%%%%%%%%%%%%%%%%
/**
 * Removes, drops and replaces stones,
 * after a swap occurred until no further
 * matches are found.
 * May take a while due to chain reactions.
 *
 * @param {Number} x1 The x1 position.
 * @param {Number} y1 The y1 position.
 * @param {Number} x2 The x2 position.
 * @param {Number} y2 The y2 position.
 */
function replaceStones(x1, y1, x2, y2) {
    var columns = removeAllStones(x1, y1, x2, y2);

    % Code for possible chain reactions
    for (var c = 0; c < columns.length; c++) {
        % Drop and add stones
        dropAddStones(columns[c]);
    }
    % Check again for stone removal
}

/**
 * Drops all stones inside the given column until there
 * are no spaces left. Top most spaces are refilled
 * using a random symbol.
 *
 * @param {Number} x The column position.
 */
function dropAddStones(x) {
    % Iterate each field of a column
    for (var y = FIELD_HEIGHT - 1; y >= 0; y--) {
        % If there is no symbol in this cell
        if (complField[y][x][0] === "") {
            % Check all fields above the current cell
            var y2 = y - 1;
            for (; y2 >= 0; y2--) {
                % If there is a non emtpy cell swap values
                if (complField[y2][x][0] !== "") {
                    complField[y][x][0] = complField[y2][x][0];
                    complField[y2][x][0] = "";
                    % Cancel loop to prevent override
                    break;
                }
            }
            % If the loop did not find a symbol a new one is needed
            if (y2 === -1) {
                % Generate randomly new stone
                var rnd = getRandomInt(cur_symbols.length);
                complField[y][x][0] = cur_symbols[rnd];
            }
            % Redraw only fields that changed
            draw(x, y);
        }
    }
}

/**
 * Removes stones for all given positions
 * from the complField.
 *
 * @param {Number} x1 The x1 position.
 * @param {Number} y1 The y1 position.
 * @param {Number} x2 The x2 position.
 * @param {Number} y2 The y2 position.
 */
function removeAllStones(x1, y1, x2, y2) {
    removeStones(x1, y1);
    return removeStones(x2, y2);
}
    var columns = [];
/**
 * Removes stones for the given position
 * from the complField.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function removeStones(x, y) {

    % Recalculate dir counts since it is not guaranteed
    % that they are up to date
    % (When hasMatch(x,y) already was true the second hasMatch is not called)
    getDirCounts(x, y);

    % Get directions in which a match can be found
    var countXPos = complField[y][x][1][0] + complField[y][x][1][2];
    var countYPos = complField[y][x][1][1] + complField[y][x][1][3];

    % If a match is found in this direction remove the stone values
    if (countXPos > 1) {
        % Just iterate from one side of the given position to the other
        for (var i = -complField[y][x][1][2]; i < complField[y][x][1][0] + 1; i++) {
            var tmpX = x + i;
            complField[y][tmpX][0] = "";
            draw(tmpX, y);
            columns.push(tmpX);
        }
    }
    if (countYPos > 1) {
        for (var i = -complField[y][x][1][3]; i < complField[y][x][1][1] + 1; i++) {
            var tmpY = y + i;
            complField[tmpY][x][0] = "";
            draw(x, tmpY);
        }
        columns.push(x);
    }
    return columns;
}

%%%%%%%%%%%%%%%%%%%%%%%%
% Get direction counts %
%%%%%%%%%%%%%%%%%%%%%%%%
/**
 * Calculates the direction counts for the given cell,
 * meaning the amount of identical symbols in each
 * of the four directions.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function getDirCounts(x, y) {
    complField[y][x][1][0] = getCount(x, y, 1, 0);
    complField[y][x][1][1] = getCount(x, y, 0, 1);
    complField[y][x][1][2] = getCount(x, y, -1, 0);
    complField[y][x][1][3] = getCount(x, y, 0, -1);
}

/**
 * Calculates the direction count for the given cell
 * in the given direction, by iterating over the field
 * in that direction.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 * @param {Number} dirX The x direction.
 * @param {Number} dirY The y direction.
 */
function getCount(x, y, dirX, dirY) {
    % Get the symbols
    var symb = complField[y][x][0];

    var count = 0;

    % Calc init position
    var nX = x + dirX;
    var nY = y + dirY;
    % Check for out of bounds
    while (nX >= 0 && nX < FIELD_WIDTH &&
        nY >= 0 && nY < FIELD_HEIGHT
    ) {
        % Check the symbol
        if (complField[nY][nX][0] === symb) {
            count++;
        } else {
            break;
        }
        nX += dirX;
        nY += dirY;
    }
    return count;
}

%%%%%%%%%%%%%%%%%%%%%
% Draw and coloring %
%%%%%%%%%%%%%%%%%%%%%
/**
 * Draw all fields.
 */
function drawAll() {
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            draw(x, y);
        }
    }
}

/**
 * Since only one field is updated with each input,
 * only this field needs to be redrawn.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function draw(x, y) {
    var field = this.getField("pos" + x + "-" + y);
    field.delay = true;
    field.value = complField[y][x][0];
    field.delay = false;
}

/**
 * Since only one field is updated with each input,
 * only this field needs to be redrawn.
 *
 * @param {Number} x The x position.
 * @param {Number} y The y position.
 */
function highlight(x, y, enable) {
    var field = this.getField("pos" + x + "-" + y);
    field.delay = true;
    % Highlight the current taken move
    if (enable) {
        field.borderColor = HIGHLIGHT_COLOR;
    } else {
        field.borderColor = color.white;
    }
    field.delay = false;
}

/**
 * Print information about the winner and the gamestate.
 */
function printInfoText(text) {
    var field = this.getField("info");
    field.delay = true;
    field.value = text;
    field.delay = false;
}

\end{insDLJS}

\OpenAction{/S /JavaScript /JS (initialise();)}
\newdimen\longline
\longline=\textwidth\advance\longline-6em
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dokument
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

    \begin{Form}

        % Header
        \begin{multicols}{2}
            % Title
            \section*{Match Me}
        \columnbreak
            % Tooltip object
            \begin{flushright}%
                \PushButton[name=tooltipbtn, bordercolor=white]{%
                    \begin{tcolorbox}[width=20pt, height=20pt, left=3pt, top=0pt]
                        \centering?\strut{}
                    \end{tcolorbox}%
                }
            \end{flushright}%
        \end{multicols}

        % Calculate the max width and height of a block
        \FPeval{\resultW}{(\fieldWidth * 4 + 3)}
        \def\blocksizeW{\dimexpr (\linewidth-\resultW pt)/\fieldWidth \relax}

        \FPeval{\resultH}{(\fieldHeight * 4 + 3)}
        \def\blocksizeH{\dimexpr (500 pt -\resultH pt)/\fieldHeight \relax}

        % Define the blocksize via the smaller amount
        \ifnum\blocksizeW<\blocksizeH
            \def\blocksize{\blocksizeW}
        \else
            \def\blocksize{\blocksizeH}
        \fi

        % The gamefield
        \begin{tcolorbox}
            \begin{flushright}
                \xintFor* #2 in {\xintSeq{0}{\fieldHeight-1}} \do {%
                    \xintFor* #1 in {\xintSeq{0}{\fieldWidth-1}} \do {%
                        \TextField[%
                            width=\blocksize, height=\blocksize,%
                            bordercolor=white, name=pos#1-#2]{}%
                    }\vspace{3pt}
                    \newline%
                }%
            \end{flushright}%
        \end{tcolorbox}

        \begin{center}
            % Game related buttons
            \begin{tabularx}{\textwidth}{@{} *{2}{X} @{}}%
                \PushButton[name=restart, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        Restart game\strut
                    \end{tcolorbox}
                } &
                \begin{tcolorbox}
                    \TextField[name=info, width=\linewidth, readonly=true]{}
                \end{tcolorbox}
            \end{tabularx}
        \end{center}

        \TextField[bordercolor=white, name=tooltiptxt]{}

    \end{Form}
\end{document}
