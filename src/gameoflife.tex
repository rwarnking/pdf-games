\documentclass[12pt, a4paper]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[margin=0.5in]{geometry}

\usepackage[pdftex]{hyperref}
\usepackage{multicol}

\usepackage{xinttools}
\usepackage[nomessages]{fp}
\usepackage{tabularx}
\usepackage{tcolorbox}

\setlength{\parindent}{0pt}

\usepackage[pdftex]{insdljs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Values can be changed
\def\fieldWidth{20}
\def\fieldHeight{20}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Javascript
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{insDLJS}[]{JSDateiname}{gameoflife}

const GAME_DESC = "Conways game of life is a cellular automaton.\
After the initial input the application will run on itself and without further interaction.\
Dependent on the state the field will evolve based on certain rules.\
The rules use the neighbourhood of a cell to determine the state of it in the next step.";

% Outside variables
const FIELD_WIDTH = AFMakeNumber(\fieldWidth);
const FIELD_HEIGHT = AFMakeNumber(\fieldHeight);

% Constants
const DEAD = 0;
const ALIVE = 1;

% Globals
% Animation interval variable
var run;
% The game field arrays
var complField1 = new Array();
var complField2 = new Array();

var currStep = 0;
var fieldIdx = 0;
var currentShape = 8;
var shapeMode = true;
var animate = false;

% Color data
const COLORS = new Array(
    color.black,
    [ "RGB", 0.843, 0.078, 0.058 ],
    [ "RGB", 0.203, 0.603, 0.054 ],
    [ "RGB", 0.078, 0.305, 0.560 ],
    [ "RGB", 0.560, 0.078, 0.533 ]
);

% Shape array that can be added to the field
const SHAPES = new Array(
    % Still lifes
    [[0, 0]], % One
    [[0, 0], [1, 0], [0, 1], [1, 1]], % Block
    [[1, 0], [2, 0], [0, 1], [3, 1], [1, 2], [2, 2]], % Beehive
    [[1, 0], [2, 0], [0, 1], [3, 1], [1, 2], [2, 3], [3, 2]], % Loaf
    [[0, 0], [1, 0], [0, 1], [2, 1], [1, 2]], % Boat
    [[1, 0], [0, 1], [2, 1], [1, 2]], % Tub
    % Oscillators
    [[1, 0], [1, 1], [1, 2]], % Blinker
    [[1, 1], [2, 1], [3, 1], [0, 2], [1, 2], [2, 2]], % Toad
    [[0, 0], [1, 0], [0, 1], [3, 2], [2, 3], [3, 3]], % Beacon
    [[4, 2], [5, 2], [6, 2], [10, 2], [11, 2], [12, 2],
        [2, 4], [7, 4], [9, 4], [14, 4],
        [2, 5], [7, 5], [9, 5], [14, 5],
        [2, 6], [7, 6], [9, 6], [14, 6],
        [4, 7], [5, 7], [6, 7], [10, 7], [11, 7], [12, 7],
        [4, 9], [5, 9], [6, 9], [10, 9], [11, 9], [12, 9],
        [2, 10], [7, 10], [9, 10], [14, 10],
        [2, 11], [7, 11], [9, 11], [14, 11],
        [2, 12], [7, 12], [9, 12], [14, 12],
        [4, 14], [5, 14], [6, 14], [10, 14], [11, 14], [12, 14]
    ], % Pulsar
    [[5, 4], [5, 5], [4, 6], [6, 6], [5, 7], [5, 8], [5, 9],
     [5, 10], [4, 11], [6, 11], [5, 12], [5, 13]], % Pentadecathlon
    % Spaceships
    [[1, 0], [2, 1], [0, 2], [1, 2], [2, 2]], % Glider
    [[0, 0], [3, 0], [4, 1], [0, 2], [4, 2],
     [1, 3], [2, 3], [3, 3], [4, 3]], % Light-weight spaceship
    [[2, 0], [0, 1], [4, 1], [5, 2], [0, 3], [5, 3],
     [1, 4], [2, 4], [3, 4], [4, 4], [5, 4]], % Middle-weight spaceship
    [[2, 0], [3, 0], [0, 1], [5, 1], [6, 2], [0, 3], [6, 3],
     [1, 4], [2, 4], [3, 4], [4, 4], [5, 4], [6, 4]] % Heavy-weight spaceship
);

%%%%%%%%%%
% Helper %
%%%%%%%%%%
/**
 * Returns a random number between 0 and the param.
 * @param {Number} max The upperbound
 */
function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initialisation and Restart %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/**
 * Initialise the default game state.
 */
function initialise() {
    for (var row = 0; row < FIELD_HEIGHT; row++) {
        var tmp1 = new Array();
        var tmp2 = new Array();
        for (var column = 0; column < FIELD_WIDTH; column++) {
            tmp1.push(DEAD);
            tmp2.push(DEAD);
        }
        complField1.push(tmp1);
        complField2.push(tmp2);
    }

    % Init the GUI
    initialiseButtons();

    % Initial run
    runAll();
}

/**
 * Initialise all buttons from the GUI.
 * For example add callbacks and set the correct colors.
 */
function initialiseButtons() {
    % Assign each button the coresponding function and disable the highlights
    var funcName = "addShape";
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            var callbackName = funcName + "(" + x.toString() + "," + y.toString() + ");";
            this.getField("pos" + x + "-" + y).setAction("MouseDown", callbackName);
            this.getField("pos" + x + "-" + y).borderColor = color.transparent;
            this.getField("pos" + x + "-" + y).fillColor = color.transparent;
        }
    }

    this.getField("animate").setAction("MouseDown", "toggleAnimation();");
    this.getField("animate").highlight="none";
    this.getField("animatetxt").setAction("MouseDown", "toggleAnimation();");
    this.getField("animatetxt").fillColor = color.transparent;
    this.getField("animatetxt").borderColor = color.transparent;
    if (animate) {
        this.getField("animatetxt").value = "On";
    } else {
        this.getField("animatetxt").value = "Off";
    }

    this.getField("step").setAction("MouseDown", "runAll();");
    this.getField("step").highlight="none";

    this.getField("shapemode").setAction("MouseDown", "toggleMode();");
    this.getField("shapemode").highlight="none";
    this.getField("shapemodetxt").setAction("MouseDown", "toggleMode();");
    this.getField("shapemodetxt").fillColor = color.transparent;
    this.getField("shapemodetxt").borderColor = color.transparent;
    if (shapeMode) {
        this.getField("shapemodetxt").value = "On";
    } else {
        this.getField("shapemodetxt").value = "Off";
    }

    this.getField("shapeidx").currentValueIndices = 0;
    this.getField("shapeidx").fillColor = color.transparent;
    this.getField("shapeidx").borderColor = color.white;

    this.getField("fillrnd").setAction("MouseDown", "fillRandom();");
    this.getField("fillrnd").highlight="none";

    this.getField("percentage").currentValueIndices = 0;
    this.getField("percentage").fillColor = color.transparent;
    this.getField("percentage").borderColor = color.white;

    this.getField("clear").setAction("MouseDown", "clear();");
    this.getField("clear").highlight="none";

    this.getField("currstep").fillColor = color.transparent;
    this.getField("currstep").borderColor = color.transparent;

    % Info field setup
    this.getField("info").fillColor = color.transparent;
    this.getField("info").borderColor = color.transparent;

    % Tooltip setup
    this.getField("tooltipbtn").setAction("MouseDown", "tooltip(true);");
    this.getField("tooltipbtn").setAction("MouseUp", "tooltip(false);");
}

/**
 * Enable or disable the tooltip.
 *
 * @param {Boolean} on Enable or disable tooltip.
 */
function tooltip(on) {
    if (on) {
        % Move the tooltip field to the center of the screen
        % and adjust the size so the text can be displayed
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = false;
        field.value = GAME_DESC;

        field.multiline = true;
        field.textSize = 16;
        % height 842, width 596
        % upper-left x, upper-left y, lower-right x and lower-right y
        field.rect = [128, 601, 468, 401];

        this.getField("tooltiptxt").setFocus();

        field.delay = false;
    } else {
        % Remove the field such that it is not visible
        var field = this.getField("tooltiptxt");
        field.delay = true;
        field.hidden = true;
        field.delay = false;
    }
}

%%%%%%%%%%%%%%%%%
% Toggle states %
%%%%%%%%%%%%%%%%%
/**
 * Start or stop the field animation.
 * Automatically disables the shapemode on switch.
 */
function toggleAnimation() {
    animate = !animate;

    var field = this.getField("animatetxt");
    field.delay = true;
    if (animate) {
        field.value = "On";

        % Animation interval
        run = app.setInterval("runAll()", 1000);
        printInfoText("Enabled animation.");

        if (shapeMode) {
            toggleMode();
            printInfoText("Enabled animation and disabled shape mode.");
        }
    } else {
        field.value = "Off";
        app.clearInterval(run);
        printInfoText("Disabled animation.");
    }
    field.delay = false;

}

/**
 * Enable or disable shapemode.
 * If the shapemode is enabled the user can add shapes to the field.
 * Automatically disables the animation on switch.
 */
function toggleMode() {
    shapeMode = !shapeMode;

    var field = this.getField("shapemodetxt");
    field.delay = true;
    if (shapeMode) {
        field.value = "On";
        printInfoText("Enabled shape mode.");

        if (animate) {
            toggleAnimation();
            printInfoText("Disabled animation and enabled shape mode.");
        }
    } else {
        field.value = "Off";
        printInfoText("Disabled shape mode.");
    }
    field.delay = false;
}

%%%%%%%%%%%%%%%%%%%%%%%
% Loop and processing %
%%%%%%%%%%%%%%%%%%%%%%%
/**
 * Main loop used for animation.
 */
function runAll() {
    process();

    fieldIdx = (fieldIdx + 1) \% 2;
    currStep++;
    this.getField("currstep").value = "Current step: " + currStep + ".";

    drawAll(fieldIdx);
}

/**
 * Calculates the next state of the gamefield, by locking at each spot
 * and writing the new state (determined by the neighbourhood) in the
 * next array.
 */
function process() {
    var state = DEAD;
    var result = DEAD;
    var n = 0;
    % Iterate all fields
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            if (fieldIdx == 1) {
                state = complField2[y][x];
            } else {
                state = complField1[y][x];
            }

            var n = getNeighbourCount(x, y);
            % Rules for when a slot is dead or alive
            if (state == DEAD && n == 3) {
                % Repopulation
                result = ALIVE;
            } else if (state == ALIVE) {
                if (n < 2) {
                    % Underpopulation
                    result = DEAD;
                } else if (n == 2 || n == 3) {
                    result = ALIVE;
                } else {
                    % Overpopulation
                    result = DEAD;
                }
            } else {
                result = DEAD;
            }

            if (fieldIdx == 1) {
                complField1[y][x] = result;
            } else {
                complField2[y][x] = result;
            }
        }
    }
}

/**
 * Calculates the amount of neighbours that are alive for the given slot x, y.
 *
 * @param {Number} pX The x coordinate.
 * @param {Number} pY The y coordinate.
 */
function getNeighbourCount(pX, pY) {
    var counter = 0;
    for (var x = pX - 1; x <= pX + 1; x++) {
        for (var y = pY - 1; y <= pY + 1; y++) {
            % Ignore own position and border
            if ((x == pX && y == pY) || x < 0 || y < 0 || x >= FIELD_WIDTH || y >= FIELD_HEIGHT) {
                continue;
            }
            if ((fieldIdx == 1 && complField2[y][x] == ALIVE) ||
                (fieldIdx == 0 && complField1[y][x] == ALIVE)
            ) {
                counter++;
            }
        }
    }
    return counter;
}

%%%%%%%%%%%%%%%%%%
% Fill and clear %
%%%%%%%%%%%%%%%%%%
/**
 * Clears both field arrays and stops animation.
 */
function clear() {
    currStep = 0;

    if (animate) {
        animate = false;
        var field = this.getField("animatetxt");
        field.delay = true;
        field.value = "Off";
        field.delay = false;

        app.clearInterval(run);

        printInfoText("Clear field and disabled animation.");
    } else {
        printInfoText("Clear field.");
    }

    % Clear all to dead
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            complField1[y][x] = DEAD;
            complField2[y][x] = DEAD;
        }
    }
    drawAll(fieldIdx);
}

/**
 * Adds the selected shape to the given coordinates, with its top left corner at
 * that position.
 *
 * @param {Number} x The x coordinate.
 * @param {Number} y The y coordinate.
 */
function addShape(x, y) {
    % Warning when shapemode is disabled
    if (!shapeMode) {
        printInfoText("Enable shape mode to add shapes.");
        return;
    }

    % Get the shape
    currentShape = this.getField("shapeidx").currentValueIndices;

    for (var pos = 0; pos < SHAPES[currentShape].length; pos++) {
        var eX = SHAPES[currentShape][pos][0] + x;
        var eY = SHAPES[currentShape][pos][1] + y;

        % Border check
        if (eX < 0 || eY < 0 || eX >= FIELD_WIDTH || eY >= FIELD_HEIGHT) {
            continue;
        }

        if (fieldIdx == 0) {
            complField1[eY][eX] = ALIVE;
        } else {
            complField2[eY][eX] = ALIVE;
        }
    };

    printInfoText("Added shape " + currentShape + ".");
    drawAll((fieldIdx + 1) \% 2);
}

/**
 * Randomise the content of the complete field given the
 * percentage specified in the gui.
 */
function fillRandom() {
    var percentage = this.getField("percentage").value;
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            if (getRandomInt(100) < percentage) {
                if (fieldIdx == 0) {
                    complField1[y][x] = ALIVE;
                } else {
                    complField2[y][x] = ALIVE;
                }
            } else {
                complField1[y][x] = DEAD;
                complField2[y][x] = DEAD;
            }
        }
    }
    drawAll((fieldIdx + 1) \% 2);
}

%%%%%%%%
% Draw %
%%%%%%%%
/**
 * Redraw all fields.
 *
 * @param {Number} idx The index of the array to draw.
 */
function drawAll(idx) {
    var field;
    for (var x = 0; x < FIELD_WIDTH; x++) {
        for (var y = 0; y < FIELD_HEIGHT; y++) {
            field = this.getField("pos" + x + "-" + y);
            field.delay = true;
            var value = DEAD;
            if (idx == 1) {
                value = complField1[y][x];
            } else {
                value = complField2[y][x];
            }

            if (value > DEAD) {
                field.fillColor = COLORS[0];
                field.borderColor = COLORS[0];
            } else {
                field.fillColor = color.transparent;
                field.borderColor = color.transparent;
            }
            field.delay = false;
        }
    }
}

/**
 * Print information about the winner and the gamestate.
 */
function printInfoText(text) {
    var field = this.getField("info");
    field.delay = true;
    field.value = text;
    field.delay = false;
}

\end{insDLJS}

\OpenAction{/S /JavaScript /JS (initialise();)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dokument
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

    \begin{Form}

        % Header
        \begin{multicols}{2}
            % Title
            \section*{Game of Life}
        \columnbreak
            % Tooltip object
            \begin{flushright}%
                \PushButton[name=tooltipbtn, bordercolor=, borderwidth=0]{%
                    \begin{tcolorbox}[width=20pt, height=20pt, left=3pt, top=0pt]
                        \centering?\strut{}
                    \end{tcolorbox}%
                }
            \end{flushright}%
        \end{multicols}

        % Dynamically adjust the cell width and height to the number of cells
        % Calculate the max width and height of a block
        \FPeval{\resultW}{(\fieldWidth * 3 - 2)} % chktex 8
        \def\blocksizeW{\dimexpr (\linewidth-\resultW pt)/\fieldWidth \relax}

        \FPeval{\resultH}{(\fieldHeight * 3 + 3)}
        \def\blocksizeH{\dimexpr (500 pt -\resultH pt)/\fieldHeight \relax}

        % The game board
        \begin{tcolorbox}
            % Define the cellsize via the smaller amount
            % Must be done here so the \linewidth has the correct value
            \ifdim\blocksizeW<\blocksizeH
                \def\blocksize{\blocksizeW}
            \else
                \def\blocksize{\blocksizeH}
            \fi

            \begin{center}
                \tiny
                \xintFor* #2 in {\xintSeq{0}{\fieldHeight-1}} \do {%
                    \xintFor* #1 in {\xintSeq{0}{\fieldWidth-1}} \do {%
                        \TextField[%
                            name=pos#1-#2, bordercolor=white,
                            width=\blocksize, height=\blocksize, readonly%
                        ]{}%
                        \xintifForLast{}{\hspace{3pt}}%
                    }\vspace{3pt}\\[-1pt]%
                }%
            \end{center}%
        \end{tcolorbox}

        % Game related buttons
        \begin{center}%
            \begin{tabularx}{\textwidth}{@{} *{2}{X} @{}}%
                \PushButton[name=animate, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        \TextField[name=animatetxt, height=0.35cm, width=0.5cm, readonly=true]%
                            {Animation:}
                        \strut
                    \end{tcolorbox}
                } &
                \PushButton[name=step, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        Next step\strut
                    \end{tcolorbox}
                } \\
                \PushButton[name=shapemode, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        \TextField[%
                            name=shapemodetxt, height=0.35cm, width=0.5cm, readonly=true%
                        ]{Shape mode:}
                        \strut
                    \end{tcolorbox}
                } &
                \begin{tcolorbox}
                    \centering
                    \ChoiceMenu[%
                        name=shapeidx, height=0.35cm, width=0.5cm, combo, commitonselchange=true]%
                            {Shape name:}{%
                        One, Block, Beehive, Loaf, Boat, Tub,%
                        Blinker, Toad, Beacon, Pulsar, Pentadecathlon,%
                        Glider, Light-weight spaceship, Middle-weight spaceship,%
                        Heavy-weight spaceship%
                    }%
                    \strut
                \end{tcolorbox} \\[-0.5cm]% TODO why do we need -0.5 here
                \PushButton[name=fillrnd, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        \ChoiceMenu[name=percentage, height=0.35cm, width=0.5cm, combo,%
                            commitonselchange=true]{Fill random with \% alive:}{%
                            20, 40, 60, 80,%
                        }%
                        \strut
                    \end{tcolorbox}
                } &%
                \begin{tcolorbox}
                    \TextField[name=currstep, width=\linewidth, readonly=true]{}
                \end{tcolorbox} \\[-0.5cm]% TODO why do we need -0.5 here
                \PushButton[name=clear, bordercolor=white]{
                    \begin{tcolorbox}
                        \centering
                        Clear\strut
                    \end{tcolorbox}
                } &
                \begin{tcolorbox}
                    \TextField[name=info, width=\linewidth, readonly=true]{}
                \end{tcolorbox}
            \end{tabularx}
        \end{center}

        \TextField[name=tooltiptxt, bordercolor=, backgroundcolor=gray, readonly, hidden]{}

    \end{Form}

\end{document}
